<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://liujia12138.github.io</id>
    <title>AzhA</title>
    <updated>2022-09-24T14:25:37.439Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://liujia12138.github.io"/>
    <link rel="self" href="https://liujia12138.github.io/atom.xml"/>
    <subtitle>温故而知新</subtitle>
    <logo>https://liujia12138.github.io/images/avatar.png</logo>
    <icon>https://liujia12138.github.io/favicon.ico</icon>
    <rights>All rights reserved 2022, AzhA</rights>
    <entry>
        <title type="html"><![CDATA[JS的作用域、预解析和声明提升]]></title>
        <id>https://liujia12138.github.io/post/js-de-zuo-yong-yu-yu-jie-xi-he-sheng-ming-ti-sheng/</id>
        <link href="https://liujia12138.github.io/post/js-de-zuo-yong-yu-yu-jie-xi-he-sheng-ming-ti-sheng/">
        </link>
        <updated>2022-09-18T07:28:18.000Z</updated>
        <content type="html"><![CDATA[<h3 id="作用域">作用域</h3>
<p>作用域就是变量的有效范围。 在一定的空间里可以对数据进行读写操作，这个空间就是数据的作用域</p>
<h4 id="1-全局作用域">1、全局作用域：</h4>
<p>最外层函数定义的变量拥有全局作用域，即对任何内部函数来说，都是 可以访问的；</p>
<h4 id="2-局部作用域">2、局部作用域：</h4>
<p>局部作用域一般只在固定的代码片段内可访问到，而对于函数外部是无 法访问的，最常见的例如函数内部。在 ES6 之前，只有函数可以划分变量的作用域，所以 在函数的外面无法访问函数内的变量</p>
<h4 id="3-块级作用域">3、块级作用域：</h4>
<p>凡是代码块就可以划分变量的作用域，这种作用域的规则就叫块级作用域</p>
<h4 id="块级作用域-函数作用域-词法作用域之间的区别">块级作用域 函数作用域 词法作用域之间的区别：</h4>
<p>3.1）块级作用域和函数作用域描述的是，什么东西可以划分变量的作用域<br>
3.2）词法作用域描述的是，变量的查找规则<br>
之间的关系：<br>
1、 块级作用域 包含 函数作用域<br>
2、 词法作用域 与 块级作用域、函数作用域之间没有任何交集， 他们从两个角度描述了作用域的规则<br>
ES6 之前 JavaScript 采用的是函数作用域+词法作用域，ES6 js 采用的是块级作用域+词法作用域</p>
<h3 id="预解析">预解析</h3>
<p>JavaScript 代码的执行是由浏览器中的 JavaScript 解析器来执行的。JavaScript 解析器执行 JavaScript 代码的时候，分为两个过程：预解析过程和代码执行过程</p>
<h4 id="预解析过程都发生了什么">预解析过程都发生了什么？</h4>
<ol>
<li>将变量的声明提升到作用域的最前面，只会提升声明，不会提升赋值。</li>
<li>将函数的声明提升到作用域的最前面，只会提升声明，不会提升调用。</li>
<li>函数提升的优先级大于变量提升的优先级</li>
</ol>
<pre><code class="language-js">// 因为var先提升，所以此处的fn是函数fn
console.log(fn);// [Function: fn]
function fn (){
  return 'fn'
}
var fn = 'aaa'
</code></pre>
<h3 id="声明提升">声明提升</h3>
<p>如上面代码，使用var关键字声明的变量，或者使用函数声明创建的函数，可以先使用后声明。<br>
需要注意的是，使用函数表达式的写法创建的函数，不会存在声明提升</p>
<pre><code class="language-js">// 函数表达式
var fn = function(){
    return 'fn'
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[js中如何判断两个对象是否相等]]></title>
        <id>https://liujia12138.github.io/post/js-zhong-ru-he-pan-duan-liang-ge-dui-xiang-shi-fou-xiang-deng/</id>
        <link href="https://liujia12138.github.io/post/js-zhong-ru-he-pan-duan-liang-ge-dui-xiang-shi-fou-xiang-deng/">
        </link>
        <updated>2022-09-18T03:30:26.000Z</updated>
        <content type="html"><![CDATA[<h4 id="1-判断两个对象的引用地址">1、判断两个对象的引用地址</h4>
<p>ES6中，提供了一个方法可以用来判断两个对象的引用地址是否一致：<code>Object.is(value1, value2)</code>。返回值为一个布尔值，如果两个对象引用地址一致则返回值为true，反之则为false</p>
<p>####2、判断两个对象内容一致<br>
想要比较两个对象的内容是否一致，需要遍历对象所有的键名和键值，判断是否完全一致。<br>
实现思路：<br>
1. 先判断两个对象引用地址是否一致<br>
2. 获取对象所有键名的数组，并且判断长度是否一致<br>
3. 遍历键名数组，判断键值是否都相等</p>
<pre><code class="language-js">function isObjectValueEqual(obj1, obj2){
    // 1.判断引用地址是否一致，一致则直接返回true
    if(Object.is(obj1, obj2)) return true
    const props1 = Object.getOwnPropertyNames(obj1)
    const props2 = Object.getOwnPropertyNames(obj2)
    // 2.判断键名数组长度是否一致，不一致则直接返回false
    if(props1.length !== props2.length) return false;
    // 3.键名数组长度一致，遍历键名数组，判断所有值是否一致
    for(let prop in obj1){
        // 3.1判断obj1的键值在obj2中是否存在，存在则进一步判断值，不存在直接返回false
        if(obj2.hasOwnProperty(prop)){
            // 3.2判断obj1的键值是否为对象，是则递归判断，否则直接判断值是否相等
            if(typeof obj1[prop] === 'object'){
                if(!isObjectValueEqual(obj1[prop],obj2[prop])) return false
            }else{
                if(obj1[prop] !== obj2[prop]) return false
            }
        }else{
            return false
        }
    }
    return true
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[JavaScript的内置对象、原生对象、宿主对象分别指的是什么？]]></title>
        <id>https://liujia12138.github.io/post/javascript-de-nei-zhi-dui-xiang-yuan-sheng-dui-xiang-su-zhu-dui-xiang-fen-bie-zhi-de-shi-shi-me/</id>
        <link href="https://liujia12138.github.io/post/javascript-de-nei-zhi-dui-xiang-yuan-sheng-dui-xiang-su-zhu-dui-xiang-fen-bie-zhi-de-shi-shi-me/">
        </link>
        <updated>2022-09-18T02:48:46.000Z</updated>
        <content type="html"><![CDATA[<h3 id="1-内置对象">1、内置对象</h3>
<p>由ECMAScript实现提供的、独立于宿主环境的所有对象。<br>
内置对象在引擎初始化阶段就已经被创建好。<br>
ECMA-262只定义了两个内置对象，即Global和Math。他们也是本地对象，即内置对象其实是本地对象的一种。</p>
<h3 id="2-原生对象">2、原生对象</h3>
<p>ECMA-262将本地对象定义为独立于宿主环境的ECMAScript实现提供对象。<br>
除了内置对象外，原生对象还包括了一些在运行过程中创建的对象。<br>
本地对象包括：Object、Function、Array、String、Number、Boolean、Date、RegExp、Error、EvalError、RangeError、ReferenceError、SyntaxError、TypeError、URLError<br>
由此可以看出，本地对象就是ECMA定义的类。</p>
<h3 id="3-宿主对象">3、宿主对象</h3>
<p>ECMAScript中的宿主就是我们网页所运行的环境，即浏览器和操作系统。<br>
所有的非本地对象都是宿主对象，即由ECMAScript实现的宿主环境提供的对象。<br>
所有的DOM和BOM都是宿主对象。因为其对于不同的宿主环境所展示的内容是不一样的。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[react 和 vue 中的 key 有什么作用？]]></title>
        <id>https://liujia12138.github.io/post/react-he-vue-zhong-de-key-you-shi-me-zuo-yong/</id>
        <link href="https://liujia12138.github.io/post/react-he-vue-zhong-de-key-you-shi-me-zuo-yong/">
        </link>
        <updated>2022-09-13T03:30:44.000Z</updated>
        <content type="html"><![CDATA[<h5 id="一-虚拟-dom-中-key-的作用">一. 虚拟 DOM 中 key 的作用：</h5>
<p>key 是虚拟 DOM 中对象的标识，当数据发生变化时，vue 会根据 新数据 生成 新的虚拟 DOM，随后 Vue 内部会进行 新虚拟 DOM 和 旧的虚拟 DOM 的差异对比（diff 算法）：</p>
<h6 id="对比规则">对比规则：</h6>
<ol>
<li>旧的虚拟 DOM 中找到与新的虚拟 DOM 中具有相同 key 值的 VNode</li>
</ol>
<ul>
<li>若虚拟 DOM 中内容没有发生变化，直接使用 之前的真实DOM，不会改变DOM</li>
<li>若虚拟 DOM 中内容发生了变化，则生成新的真实 DOM，随后替换掉页面中之前的真实 DOM</li>
</ul>
<ol start="2">
<li>旧的虚拟 DOM 中没有找到与新的虚拟 DOM 具有相同 key 值的 VNode<br>
创建新的真实 DOM，然后渲染到页面上</li>
</ol>
<h5 id="二-用-index-作为-key-值可能会引发的问题">二. 用 index 作为 key 值可能会引发的问题？</h5>
<ol>
<li>若对数据进行：逆序添加、逆序删除等破坏原有顺序的操作，会产生没有必要的真实 DOM 更新，页面效果没有问题，但是效率低（因为对数据的顺序进行了改变，导致没有发生变化的数据在渲染时也无法使用之前的真实DOM）</li>
<li>如果结构中还包含了输入类的 DOM，如 input，会产生错误的 DOM 更新，导致页面有问题，如：</li>
</ol>
<pre><code class="language-html">&lt;template&gt;
  &lt;div&gt;
    &lt;button @click=&quot;addPerson&quot;&gt;向列表前添加一个人&lt;/button&gt;
    &lt;ul&gt;
      &lt;li v-for=&quot;(item,index) in persons&quot; :key=&quot;index&quot;&gt;
        {{item.name}}---{{index}}
        &lt;!-- 每人一个输入框 --&gt;
        &lt;input type=&quot;text&quot; /&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
  export default{
    data(){
      return {
        person: [
          {
            name: '张三',
            id: '001'
          },{
            name: '李四',
            id: '002'
          },{
            name: '王五',
            id: '003'
          }
        ]
      }
    },
    methods:{
      addPerson(){
        let p = {
          name: '老刘',
          id: '004
        }
        this.person.upshift(p)
      }
    }
  }
&lt;/script&gt;
</code></pre>
<p>页面渲染出persons列表后在每行的input中输入姓名<br>
效果图:<br>
<img src="https://liujia12138.github.io/post-images/1663040035727.jpg" alt="" loading="lazy"></p>
<p>点击按钮，添加老刘后<br>
<img src="https://liujia12138.github.io/post-images/1663040050410.jpg" alt="" loading="lazy"></p>
<p>此时页面上老刘数据添加到persons的第一位，姓名和index都正常渲染，但是input出现了错位的情况。<br>
这是因为旧的虚拟DOM中张三和新的虚拟DOM中老刘具有相同的key：0，diff算法在进行差异对比时，发现name不同，然后页面渲染时就会渲染上新的name，但是对于input，由于上一步在input中输入姓名的操作是发生在真实DOM中的，没有影响到虚拟DOM，所以，在进行对比时会认为这一部分没有发生变化，这时页面就会继续使用上一次渲染的input，这也就导致了‘老刘’这条数据在页面上的input是张三的。</p>
<p>对比过程图<br>
<img src="https://liujia12138.github.io/post-images/1663040060872.jpg" alt="" loading="lazy"></p>
<h5 id="三开发中如何选择key">三.开发中如何选择key？</h5>
<ol>
<li>最好使用每条数据的唯一标识作为key，比如id，手机号，身份证号等唯一值</li>
<li>如果不存在对数据逆序添加、逆序删除等破坏顺序的操作，仅用于渲染列表展示，使用index作为key是不会有问题的</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[定时任务时间表达式规则]]></title>
        <id>https://liujia12138.github.io/post/ding-shi-ren-wu-shi-jian-biao-da-shi-gui-ze/</id>
        <link href="https://liujia12138.github.io/post/ding-shi-ren-wu-shi-jian-biao-da-shi-gui-ze/">
        </link>
        <updated>2022-08-10T07:05:16.000Z</updated>
        <content type="html"><![CDATA[<h3 id="为什么需要时间表达式">为什么需要时间表达式</h3>
<p>数据中台项目中，需要定时执行规则来进行数据质量的检核，这个定时的规则通常是用户在后台进行配置的。</p>
<h3 id="定时任务时间表达式规则">定时任务时间表达式规则</h3>
<p>时间表达式组件一般由秒、分、时、日、月、周（星期几）、年7个域组成<br>
对应的生成的表达式也是由 s、m、h、d、M、w、y 7个值由空格拼接生成</p>
<h5 id="各个域的含义和可选值">各个域的含义和可选值：</h5>
<table>
<thead>
<tr>
<th>域</th>
<th style="text-align:center">取值</th>
<th>特殊字符</th>
</tr>
</thead>
<tbody>
<tr>
<td>1.秒</td>
<td style="text-align:center">0-59</td>
<td>, - / *</td>
</tr>
<tr>
<td>2.分</td>
<td style="text-align:center">0-59</td>
<td>, - / *</td>
</tr>
<tr>
<td>3.时</td>
<td style="text-align:center">0-23</td>
<td>, - / *</td>
</tr>
<tr>
<td>4.日</td>
<td style="text-align:center">1-31</td>
<td>, - / * ? L W</td>
</tr>
<tr>
<td>5.月</td>
<td style="text-align:center">1-12</td>
<td>, - / *</td>
</tr>
<tr>
<td>6.周</td>
<td style="text-align:center">1-7或SUN-SAT</td>
<td>, - / * ? L</td>
</tr>
<tr>
<td>7.年</td>
<td style="text-align:center">1970-2099</td>
<td>, - / *</td>
</tr>
</tbody>
</table>
<h5 id="特殊字符的含义">特殊字符的含义</h5>
<p>* : 表示匹配该域的任意值。比如Minutes域使用*，就表示每分钟都会触发。<br>
- : 表示范围。比如Minutes域使用 10-20，就表示从10分钟到20分钟每分钟都会触发一次。<br>
, : 表示列出枚举值。比如Minutes域使用1,3，就表示1分钟和3分钟都会触发一次。<br>
/ : 表示间隔时间触发(开始时间/时间间隔)。例如在Minutes域使用 5/10，就表示从第5分钟开始，每隔10分钟触发一次。<br>
? : 表示不指定值。简单理解就是忽略该字段的值，直接根据另一个字段的值触发执行。<br>
# : 表示该月第n个星期x(x#n)，仅用星期域。如：星期：6#3，表示该月的第三个星期五。<br>
L : 表示最后，是单词&quot;last&quot;的缩写（最后一天或最后一个星期几）；仅出现在日和星期的域中。用在日则表示该月的最后一天，用在星期则表示该月的最后一个星期。如：星期域上的值为5L，则表示该月最后一个星期的星期四。在使用'L'时，不要指定列表','或范围'-'，否则易导致出现意料之外的结果。<br>
W: 仅用在日的域中，表示距离当月给定日期最近的工作日（周一到周五），是单词&quot;weekday&quot;的缩写。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[vue+webpack 实现多入口架构]]></title>
        <id>https://liujia12138.github.io/post/vuewebpack-shi-xian-duo-ru-kou-jia-gou/</id>
        <link href="https://liujia12138.github.io/post/vuewebpack-shi-xian-duo-ru-kou-jia-gou/">
        </link>
        <updated>2022-05-18T07:12:30.000Z</updated>
        <content type="html"><![CDATA[<h4 id="一-为什么需要多入口多页面项目">一、为什么需要多入口多页面项目？</h4>
<p>vue 项目大多是单页面项目，即一个 main.js 入口文件，一般情况下使用 webpack 默认配置就可以。但是如果项目很大，有很多个小的分项目，比如一个数据处理平台需要包含数据接入、数据处理、数据输出等分项目，这时把这几个分项目合并到一个项目中管理会方便很多。</p>
<h4 id="二-多页面可以解决哪些问题">二、多页面可以解决哪些问题？</h4>
<ul>
<li>独立维护子系统的权限和缓存数据</li>
<li>开发一个子系统时，不需要启动另外一个系统</li>
<li>热更新一个子系统时，不需要编译所有系统</li>
</ul>
<h4 id="三-怎样配置一个-vue-多页面应用">三、怎样配置一个 vue 多页面应用</h4>
<h5 id="1先创建一个-vue-项目">1.先创建一个 vue 项目</h5>
<pre><code>vue init webpack project-name
</code></pre>
<h5 id="2给每个子系统创建-mainjs-appvue-indexhtml-文件最终目录结构如下">2.给每个子系统创建 main.js、App.vue、index.html 文件，最终目录结构如下</h5>
<pre><code>├─build
├─config
├─node_modules
├─src
|  ├─api
|  ├─assets
|  ├─components
|  ├─layout
|  ├─pages
|  |  ├─system1
|  |  | ├─views
|  |  | ├─store
|  |  | ├─router
|  |  |  main.js
|  |  |  index.html
|  |  ├─system2
|  |  | ├─views
|  |  | ├─store
|  |  | ├─router
|  |  |  main.js
|  |  |  index.html
|    ...

</code></pre>
<h5 id="3修改-webpack-配置文件">3.修改 webpack 配置文件</h5>
<p>基础配置 webpack.base.conf.js</p>
<pre><code class="language-js">const glob = require('glob')
const path = require('path')
const HtmlWebpackPlugin = require('html-webpack-plugin')

function resolve(dir) {
  return path.join(__dirname, '..', dir)
}

const entrys = {} //入口文件配置
const pageDir = resolve('src/pages')

const pages = glob.sync('*/index.html', { cwd: pageDir }).map((p) =&gt; {
  const name = p.split('/')[0]
  entrys[name] = `${pageDir}/${name}/main.js`
  return new HtmlWebpackPlugin({
    filename: `${name}.html`,
    template: pageDir + '/' + p,
    chunks: ['manifest', 'vendor', 'app', name],
    inject: true,
    favicon: './static/favicon.ico',
    minify: {
      removeComments: true,
      collapseWhitespace: true,
      removeAttributeQuotes: true
    },
    chunksSortMode: 'dependency'
  })
})

module.exports = {
  context: path.resolve(__dirname, '../'),
  entry: entrys,
  output: {
    path: config.build.assetsRoot,
    filename: '[name].js',
    publicPath: process.env.NODE_ENV === 'production' ? config.build.assetsPublicPath : config.dev.assetsPublicPath
  },
  plugins: [...pages]
  // 其他。。。。
}
</code></pre>
<p>开发环境配置 webpack.dev.conf.js，HtmlWebpackPlugin 已经在基础配置中修改，dev 环境不需要再修改</p>
<p>生产环境配置 webpack.prod.conf.js，修改output</p>
<pre><code class="language-js">modules.exports = {
  // ....
  output: {
    path: config.build.assetsRoot,
    filename: utils.assetsPath('js/[name].[chunkhash].js'),
    chunkFilename: utils.assetsPath('js/[id].[chunkhash].js'),
    publicPath: '/'
  },
  plugins: [
    // 公共模块单独打包
    new webpack.optimize.CommonsChunkPlugin({
      name: 'vendor',
      minChunks(module) {
        return (
          module.resource &amp;&amp;
          /\.js$/.test(module.resource) &amp;&amp;
          module.resource.indexOf(path.join(__dirname, '../node_modules')) === 0
        )
      }
    }),
    new webpack.optimize.CommonsChunkPlugin({
      name: 'manifest',
      minChunks: Infinity
    }),
    new webpack.optimize.CommonsChunkPlugin({
      name: 'app',
      async: 'vendor-async',
      children: true,
      minChunks: 3,
      maxChunks: 10
    })
  ]
}
</code></pre>
<h5 id="4运行项目">4.运行项目</h5>
<pre><code>npm run dev
</code></pre>
<p>http://localhost:8080/system1.html#/home  就可以访问啦</p>
<h5 id="5打包">5.打包</h5>
<pre><code>npm run build
</code></pre>
<p>打包结果</p>
<pre><code>dist
├─system1.html
├─system2.html
├─static
| ├─css
| ├─js
| ├─fonts
| ├─img
| ├─static
└ ├─js
</code></pre>
<h4 id="四-后续优化">四、后续优化</h4>
<p>1.单独构建、打包某个子系统<br>
2.子系统特有依赖模块打包策略</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[eslint+prettier 代码规范自动化配置]]></title>
        <id>https://liujia12138.github.io/post/eslintprettier-dai-ma-gui-fan-zi-dong-hua-pei-zhi/</id>
        <link href="https://liujia12138.github.io/post/eslintprettier-dai-ma-gui-fan-zi-dong-hua-pei-zhi/">
        </link>
        <updated>2022-05-10T07:16:22.000Z</updated>
        <content type="html"><![CDATA[<p>Eslint:</p>
<ol>
<li>安装：eslint^6.7.2 eslint-plugin-vue^6.2.2 babel-eslint^10.1.0</li>
<li>安装 vue-cli eslint 插件： @vue/cli-plugin-eslint</li>
<li>scripts 中加入命令： <code>&quot;lint&quot;:&quot;vue-cli-service lint&quot;</code></li>
<li>.eslintrc.js 文件中加入相关配置</li>
<li>.eslintignore 文件中配置忽略的目录及文件</li>
</ol>
<p>Prettier:</p>
<ol>
<li>项目目录下新建.prettierrc.js，并添加相关配置</li>
<li>项目目录下新建.prettierigonre，配置格式化忽略的文件</li>
<li>package.json 中添加命令: <code>&quot;format&quot;:&quot;prettier —write 'src/\*_/_.{js,vue,css,scss}'&quot;</code></li>
<li>运行 <code>npm run format</code> 即可完成项目文件批量格式化</li>
</ol>
<p>prettier 配置：</p>
<pre><code class="language-js">module.exports = {
  printWidth: 140, // 超过最大值换行
  tabWidth: 2,
  useTabs: false,
  semi: false, // 句尾不添加分号
  singleQuote: true, // 使用单引号
  quoteProps: 'as-needed',
  jsxSingleQuote: true,
  trailingComma: 'none',
  bracketSpacing: true, // 在对象，数组括号与文字之间加空格 &quot;{ foo: bar }&quot;
  jsxBracketSameLine: true, // 在jsx中把'&gt;' 是否单独放一行
  arrowParens: 'always', // 箭头函数单个参数省略括号
  insertPragma: false,
  proseWrap: 'preserve',
  htmlWhitespaceSensitivity: 'ignore',
  vueIndentScriptAndStyle: false, // vue script和style标签中是否缩进
  endOfLine: 'auto',
  embeddedLanguageFormatting: 'auto'
}
</code></pre>
<p>eslint 配置</p>
<pre><code class="language-js">module.exports = {
  root: true,
  parserOptions: {
    parser: 'babel-eslint',
    sourceType: 'module'
  },
  env: {
    browser: true,
    node: true,
    es6: true
  },
  extends: ['plugin:vue/recommended', 'eslint:recommended'],

  // add your custom rules here
  // it is base on https://github.com/vuejs/eslint-config-vue
  rules: {
    'vue/max-attributes-per-line': [
      //强制每行的最多属性数
      2,
      {
        singleline: 10, // 单行情况下每行最多十个属性
        multiline: {
          max: 1,
          allowFirstLine: false
        }
      }
    ],
    'vue/html-self-closing': [
      //html标签强制执行自闭式
      'error',
      {
        html: {
          void: 'any',
          normal: 'any',
          component: 'any'
        },
        svg: 'any',
        math: 'any'
      }
    ],
    'vue/singleline-html-element-content-newline': 'off', // 在单行元素的内容前后使用换行符
    'vue/no-parsing-error': [2, { 'invalid-first-character-of-tag-name': false }],
    'vue/no-use-v-if-with-v-for': 1,
    'vue/multiline-html-element-content-newline': 'off', // 在多行元素的内容前后使用换行符
    'vue/name-property-casing': [0, 'PascalCase'],
    'vue/html-closing-bracket-newline': [
      0,
      {
        singleline: 'never',
        multiline: 'always'
      }
    ],
    'vue/no-side-effects-in-computed-properties': 0,
    'accessor-pairs': 2, //在对象中使用getter/setter
    'arrow-spacing': [
      2,
      {
        before: true,
        after: true
      }
    ], //=&gt;的前/后括号
    'block-spacing': [2, 'always'], //块是否需要空格
    // if while function 后面的{必须与if在同一行，java风格。
    'brace-style': [
      2,
      '1tbs',
      {
        allowSingleLine: true
      }
    ],
    //强制驼峰法命名
    camelcase: [
      0,
      {
        properties: 'always'
      }
    ],
    // 数组和对象键值对最后一个逗号， never参数：不能带末尾的逗号, always参数：必须带末尾的逗号，
    // always-multiline：多行模式必须带逗号，单行模式不能带逗号
    'comma-dangle': [2, 'never'],
    // 控制逗号前后的空格
    'comma-spacing': [
      2,
      {
        before: false,
        after: true
      }
    ],
    'comma-style': [2, 'last'], // 控制逗号在行尾出现还是在行首出现
    // 强制在子类构造函数中用super()调用父类构造函数，TypeScrip的编译器也会提示
    'constructor-super': 2,
    // 强制object.key 中 . 的位置，参数:
    // property，'.'号应与属性在同一行
    // object, '.' 号应与对象名在同一行
    'dot-location': [2, 'property'],
    'eol-last': 2, // 文件末尾强制换行
    eqeqeq: [2, 'allow-null'], // 使用 === 替代 ==
    'generator-star-spacing': 0, //生成器函数*的前后空格
    'handle-callback-err': 0, //nodejs 处理错误
    indent: [
      2,
      2,
      {
        //缩进风格
        SwitchCase: 1
      }
    ],
    // JSX 属性中一致使用双引号或单引号
    'jsx-quotes': [2, 'prefer-single'],
    //对象字面量中冒号的前后空格
    'key-spacing': [
      2,
      {
        beforeColon: false,
        afterColon: true
      }
    ],
    'keyword-spacing': [
      2,
      {
        before: true,
        after: true
      }
    ],
    //函数名首行大写必须使用new方式调用，首行小写必须用不带new方式调用
    'new-cap': [
      2,
      {
        newIsCap: true,
        capIsNew: false
      }
    ],
    'new-parens': 2, //new时必须加小括号
    'no-array-constructor': 2, //禁止使用数组构造器
    'no-caller': 2, //禁止使用arguments.caller或arguments.callee
    'no-console': process.env.NODE_ENV === 'production' ? 2 : 0, //禁止使用console
    'no-class-assign': 2, //禁止给类赋值
    'no-cond-assign': 2, //禁止在条件表达式中使用赋值语句
    'no-const-assign': 2, //禁止修改const声明的变量
    'no-control-regex': 0, //禁止在正则表达式中使用控制字符
    'no-delete-var': 2, //不能对var声明的变量使用delete操作符
    'no-dupe-args': 2, //函数参数不能重复
    'no-dupe-class-members': 2, //不允许类中出现重复的声明
    'no-dupe-keys': 2, //在创建对象字面量时不允许键重复 {a:1,a:1}
    'no-duplicate-case': 2, //switch中的case标签不能重复
    'no-empty-character-class': 0, //正则表达式中的[]内容不能为空
    'no-empty-pattern': 0,
    'no-eval': 0, //禁止使用eval
    'no-ex-assign': 2, //禁止给catch语句中的异常参数赋值
    'no-extend-native': 2, //禁止扩展native对象
    'no-extra-bind': 2, //禁止不必要的函数绑定
    'no-extra-boolean-cast': 2, //禁止不必要的bool转换
    'no-extra-parens': [2, 'functions'], //禁止非必要的括号
    'no-fallthrough': 2, //禁止switch穿透
    'no-floating-decimal': 2, //禁止省略浮点数中的0 .5 3.
    'no-func-assign': 2, //禁止重复的函数声明
    'no-implied-eval': 2, //禁止使用隐式eval
    'no-inner-declarations': [2, 'functions'], //禁止在块语句中使用声明（变量或函数）
    'no-invalid-regexp': 2, //禁止无效的正则表达式
    'no-irregular-whitespace': 2, //不能有不规则的空格
    'no-iterator': 2, //禁止使用__iterator__ 属性
    'no-label-var': 2, //label名不能与var声明的变量名相同
    'no-labels': [
      2,
      {
        //禁止标签声明
        allowLoop: false,
        allowSwitch: false
      }
    ],
    'no-lone-blocks': 2, //禁止不必要的嵌套块
    'no-mixed-spaces-and-tabs': 2, //禁止混用tab和空格
    'no-multi-spaces': 2, //不能用多余的空格
    'no-multi-str': 2, //字符串不能用\换行
    'no-multiple-empty-lines': [
      0,
      {
        max: 1
      }
    ], //空行最多不能超过1行
    'no-native-reassign': 2, //不能重写native对象
    'no-negated-in-lhs': 2, //in 操作符的左边不能有!
    'no-new-object': 2, //禁止使用new Object()
    'no-new-require': 2, //禁止使用new require
    'no-new-symbol': 2, //禁止使用new symbol
    'no-new-wrappers': 2, //禁止使用new创建包装实例，new String new Boolean new Number
    'no-obj-calls': 0, //不能调用内置的全局对象，比如Math() JSON()
    'no-octal': 2, //禁止使用八进制数字
    'no-octal-escape': 2, //禁止使用八进制转义序列
    'no-path-concat': 2, //node中不能使用__dirname或__filename做路径拼接
    'no-proto': 2, //禁止使用__proto__属性
    'no-redeclare': 2, //禁止重复声明变量
    'no-regex-spaces': 2, //禁止在正则表达式字面量中使用多个空格 /foo bar/
    'no-return-assign': [2, 'except-parens'], //return 语句中不能有赋值表达式
    'no-self-assign': 2, //自我分配
    'no-self-compare': 2, //不能比较自身
    'no-sequences': 2, //禁止使用逗号运算符
    'no-shadow-restricted-names': 2, //严格模式中规定的限制标识符不能作为声明时的变量名使用
    'no-spaced-func': 2, //函数调用时 函数名与()之间不能有空格
    'no-sparse-arrays': 2, //禁止稀疏数组， [1,,2]
    'no-this-before-super': 2, //在调用super()之前不能使用this或super
    'no-throw-literal': 2, //禁止抛出字面量错误 throw &quot;error&quot;;
    'no-trailing-spaces': 0, //一行结束后面不要有空格
    'no-undef': 2, //不能有未定义的变量
    'no-undef-init': 2, //变量初始化时不能直接给它赋值为undefined
    'no-unexpected-multiline': 0, //避免多行表达式
    'no-unmodified-loop-condition': 0, //检查引用是否在循环中被修改
    'no-unneeded-ternary': 0, //禁止不必要的嵌套 var isYes = answer === 1 ? true : false;
    'no-unreachable': 2, //不能有无法执行的代码
    'no-unsafe-finally': 0,
    'no-unused-vars': [
      2,
      {
        vars: 'all',
        args: 'none'
      }
    ], //不能有声明后未被使用的变量或参数
    'no-useless-call': 2, //禁止不必要的call和apply
    'no-useless-computed-key': 0, //没有必要使用带文字的计算属性
    'no-useless-constructor': 2, //可以在不改变类的工作方式的情况下安全地移除的类构造函数
    'no-useless-escape': 0,
    'no-whitespace-before-property': 0,
    'no-with': 2, //禁用with
    'one-var': 0, //连续声明
    'operator-linebreak': [
      2,
      'after',
      {
        overrides: {
          '?': 'before',
          ':': 'before'
        }
      }
    ], //换行时运算符在行尾还是行首
    'padded-blocks': 0, //块语句内行首行尾是否要空行
    quotes: [
      2,
      'single',
      {
        avoidEscape: true,
        allowTemplateLiterals: true
      }
    ], //引号类型 `` &quot;&quot; ''
    semi: [2, 'never'], //语句强制分号结尾
    'semi-spacing': [
      2,
      {
        before: false,
        after: true
      }
    ], //分号前后空格
    'space-before-blocks': [2, 'always'], //不以新行开始的块{前面要不要有空格
    'space-before-function-paren': [2, 'never'], //函数定义时括号前面要不要有空格
    'space-in-parens': [2, 'never'], //小括号里面要不要有空格
    'space-infix-ops': 2, //中缀操作符周围要不要有空格
    'space-unary-ops': [
      2,
      {
        words: true,
        nonwords: false
      }
    ], //一元运算符的前/后要不要加空格
    'spaced-comment': 0, //注释风格不要有空格什么的
    'template-curly-spacing': [2, 'never'],
    'use-isnan': 2, //禁止比较时使用NaN，只能用isNaN()
    'valid-typeof': 2, //必须使用合法的typeof的值
    'wrap-iife': [2, 'any'], //立即执行函数表达式的小括号风格
    'yield-star-spacing': 0,
    yoda: [2, 'never'], //禁止尤达条件
    'prefer-const': 2, //首选const
    'no-debugger': process.env.NODE_ENV === 'production' ? 2 : 0, //禁止使用debugger
    'object-curly-spacing': [
      2,
      'always',
      {
        objectsInObjects: false
      }
    ], //大括号内是否允许不必要的空格
    'array-bracket-spacing': [2, 'never'] //是否允许非空数组里面有多余的空格
  }
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[用van-calendar实现展示指定月份并自定义日期文案]]></title>
        <id>https://liujia12138.github.io/post/yong-van-calendar-shi-xian-zhan-shi-zhi-ding-yue-fen-bing-zi-ding-yi-ri-qi-wen-an/</id>
        <link href="https://liujia12138.github.io/post/yong-van-calendar-shi-xian-zhan-shi-zhi-ding-yue-fen-bing-zi-ding-yi-ri-qi-wen-an/">
        </link>
        <updated>2022-04-27T07:19:26.000Z</updated>
        <content type="html"><![CDATA[<p>效果图:<br>
<img src="https://liujia12138.github.io/post-images/1663053616494.jpg" alt="" loading="lazy"></p>
<p>代码：</p>
<pre><code>&lt;template&gt;
  &lt;div&gt;
    &lt;van-button icon=&quot;notes-o&quot; round type=&quot;info&quot; plain size=&quot;mini&quot; @click=&quot;showPicker = true&quot;&gt;
      选择日期&lt;van-icon name=&quot;arrow-down&quot; /&gt;
    &lt;/van-button&gt;

    &lt;van-popup v-model=&quot;showPicker&quot; position=&quot;bottom&quot;&gt;
      &lt;van-datetime-picker
        title=&quot;选择日期&quot;
        type=&quot;year-month&quot;
        v-model=&quot;currentDate&quot;
        :columns-order=&quot;['year', 'month', 'day']&quot;
        @confirm=&quot;onConfirm&quot;
        @cancel=&quot;showPicker = false&quot;
        :formatter=&quot;formatter&quot;
        :max-date=&quot;maxDate&quot;
      /&gt;
    &lt;/van-popup&gt;

    &lt;van-calendar
      v-if=&quot;this.dataList.length &gt; 0&quot;
      :poppable=&quot;false&quot;
      :formatter=&quot;formatterCalendar&quot;
      :default-date=&quot;defaultDate&quot;
      :min-date=&quot;minDate&quot;
      :max-date=&quot;calendarMaxDate&quot;
      :show-title=&quot;false&quot;
      :show-subtitle=&quot;false&quot;
      :show-confirm=&quot;false&quot;
      @select=&quot;selectDate&quot;
    /&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
/**
 * Parse the time to string
 * @param {(Object|string|number)} time
 * @param {string} cFormat
 * @returns {string}
 */
function parseTime(time, cFormat) {
  if (arguments.length === 0) {
    return null
  }
  const format = cFormat || '{y}-{m}-{d} {h}:{i}:{s}'
  let date
  if (typeof time === 'object') {
    date = time
  } else {
    if (typeof time === 'string' &amp;&amp; /^[0-9]+$/.test(time)) {
      time = parseInt(time)
    }
    if (typeof time === 'number' &amp;&amp; time.toString().length === 10) {
      time = time * 1000
    }
    date = new Date(time)
  }
  const formatObj = {
    y: date.getFullYear(),
    m: date.getMonth() + 1,
    d: date.getDate(),
    h: date.getHours(),
    i: date.getMinutes(),
    s: date.getSeconds(),
    a: date.getDay()
  }
  const time_str = format.replace(/{(y|m|d|h|i|s|a)+}/g, (result, key) =&gt; {
    let value = formatObj[key]
    // Note: getDay() returns 0 on Sunday
    if (key === 'a') {
      return ['日', '一', '二', '三', '四', '五', '六'][value]
    }
    if (result.length &gt; 0 &amp;&amp; value &lt; 10) {
      value = '0' + value
    }
    return value || 0
  })
  return time_str
}

export default {
  data() {
    return {
      showPicker: false,
      currentDate: new Date(),
      maxDate: new Date(),
      minDate: new Date(),
      calendarMaxDate: new Date(),
      defaultDate: new Date(),
      dataList: [],
      classList: {}
    }
  },
  computed: {
    formatDate() {
      return parseTime(this.currentDate, this.pickerType === 'date' ? '{y}年{m}月{d}日' : '{y}年{m}月')
    }
  },
  created() {
    this.update()
  },
  methods: {
    formatter(type, val) {
      if (type === 'year') {
        return val + '年'
      }
      if (type === 'month') {
        return val + '月'
      }
      if (type === 'day') {
        return val + '日'
      }
      return val
    },
    onConfirm(value) {
      this.showPicker = false
      this.update(value)
    },
    formatterCalendar(day) {
      const date = day.date.getDate()
      const type = this.dataList[date - 1] || ''

      day.bottomInfo = type
      day.className =
        type === '优'
          ? 'level1'
          : type === '良'
          ? 'level2'
          : type === '轻度'
          ? 'level3'
          : type === '中度'
          ? 'level4'
          : type === '重度'
          ? 'level5'
          : 'level6'
      return day
    },
    update(value) {
      this.dataList = ['优', '良', '中度', '重度', '严重', '优', '优', '良', '中度', '重度', '严重']
      this.defaultDate = value || new Date()
      this.setMinMaxDay()
    },
    // 设置显示月份可选择的天数区间
    setMinMaxDay() {
      const year = new Date(this.defaultDate).getFullYear()
      const month = new Date(this.defaultDate).getMonth()
      const lastDay = new Date(year, month + 1, 0)
      this.minDate = new Date(year, month, 1)
      this.calendarMaxDate = lastDay
    },
    selectDate(date) {
      console.log(date)
    }
  }
}
&lt;/script&gt;
&lt;style&gt;
.van-calendar__month-title {
  display: none;
}
.van-calendar__day {
  font-size: 12px;
  height: 30px;
  line-height: 30px;
  margin-top: 5px;
}
.van-calendar__selected-day {
  background: #cdcbc8;
  color: #515151;
  height: 30px;
  line-height: 30px;
}
.van-calendar__bottom-info {
  border-radius: 5px;
  font-size: 10px;
  padding: 1px 3px;
  color: #fff;
  position: initial;
  vertical-align: middle;
  margin-left: 5px;
}
.level1 .van-calendar__bottom-info {
  background: #b0cb8f;
}
.level2 .van-calendar__bottom-info {
  background: #f2d875;
}
.level3 .van-calendar__bottom-info {
  background: #e5a74c;
}
.level4 .van-calendar__bottom-info {
  background: #cc6065;
}
.level5 .van-calendar__bottom-info {
  background: #ac4176;
}
.level6 .van-calendar__bottom-info {
  background: #7d1f2c;
}
&lt;/style&gt;

</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[怎样实现一个控制台都删不掉的 DOM（保护水印）]]></title>
        <id>https://liujia12138.github.io/post/zen-yang-shi-xian-yi-ge-kong-zhi-tai-du-shan-bu-diao-de-dombao-hu-shui-yin/</id>
        <link href="https://liujia12138.github.io/post/zen-yang-shi-xian-yi-ge-kong-zhi-tai-du-shan-bu-diao-de-dombao-hu-shui-yin/">
        </link>
        <updated>2022-04-19T07:17:25.000Z</updated>
        <content type="html"><![CDATA[<h4 id="mutationobserver">MutationObserver</h4>
<p>MutationObserver 提供了监视对 DOM 树所做更改的能力。他被设计为旧的 Mutation Events 功能的替代品，是 DOM3 Event 规范的一部分。<br>
MutationObserver 构造函数会创建并返回一个新的 MutationObserver，在指定的 DOM 发生变化时被调用</p>
<h5 id="方法">方法</h5>
<ol>
<li>
<p>disconnect()<br>
阻止 MutationObserver 实例继续接收的通知，直到再次调用其 observe()方法，该观察者对象包含的回调函数都不会再被调用</p>
</li>
<li>
<p>observe(options)<br>
配置 MutationObserver 在 DOM 更改匹配给定选项时，通过其回调函数开始接收通知。<br>
注意：当调用observe方法时，childList、attributes或者characterData三个属性中，至少有一个必须为true，否则会抛出异常。<br>
options：</p>
<ol>
<li>attributeFilter：要监视的特定属性名称的列表。如果未包含此属性，则对所有属性的更改都会触发变动通知。无默认值。</li>
<li>attributeOldValue：当监视节点的属性改动时，将此属性设置为true，将会记录任何有改动的属性的上一个值。有关观察属性更改和值记录的详细信息。无默认值。</li>
<li>attributes：设置为true时，可以观察受监视元素的属性值的变更。默认为false。</li>
<li>characterData：设置为true时，可以监视指定目标节点或子节点树中节点所包含的字符数据的变化。无默认值</li>
<li>characterDataOldValue：设置为true时，可以在受监视节点上文本数据发生变化时记录节点文本的上一个值。无默认值。</li>
<li>childList：设为true，可以监视目标节点添加或删除子节点的操作。默认值为false。</li>
<li>subtree：设为true，可以将监视范围扩展至目标节点整个节点数树中的所有节点（即子孙节点），MutationObserverInit的其他值也会作用于此子树下的所有节点，而不仅仅只作用于目标节点。默认值为false。</li>
</ol>
</li>
<li>
<p>takeRecords()<br>
从 MutationObserver 的通知队列中删除所有待处理的通知，并将它们返回到 MutationRecord 对象的新 Array 中。</p>
</li>
</ol>
<pre><code class="language-js">const styleStr = `
      position: fixed;
      bottom: 150px;
      left: 200px;
      z-index: 9999;
      transform: rotateZ(-45deg);
      opacity: 0.6;
    `
const nodeId = sjs(10)

createDiv()
parentObserver()

function createDiv() {
  const ele = document.createElement('canvas')
  const ctx = ele.getContext('2d')
  ctx.fillText('MutationObserver', 15, 50)
  ele.setAttribute('id', nodeId)
  ele.setAttribute('style', styleStr)
  document.body.appendChild(ele)
  wmObserver(ele)
}

// wmObserver 监听水印，防止修改水印样式
// 参考：https://juejin.cn/post/7020602166591111205
// 因为水印的样式可以通过控制台修改，如果被设置了 display:none 等样式，也会失去保护作用
// 对于这种情况，我们可以监听水印DOM的style属性，当属性发生变动时，再通过 setAttribute 将正确的样式设置到DOM上
function wmObserver(ele) {
  new MutationObserver(function (mutationsList, observe) {
    const target = mutationsList[0].target
    target.setAttribute('style', styleStr)
    observe.takeRecords()
  }).observe(ele, { attributes: true, childList: true, characterData: true })
}

// parentObserver 监听父级，防止删除水印dom
// 因为被监听的目标节点本身被删除的话是不会触发MutationObserver回调的，所以需要监听水印DOM节点的父元素或者body元素
// 当body作为监听的目标节点时，只有删除掉body时MutationObserver才会失效，此时页面内需要保护的内容也就已经被删掉了，有无水印的意义不大。
function parentObserver() {
  new MutationObserver(function () {
    var e = document.querySelector('#' + nodeId)
    console.log(e)
    // 没有找到水印的dom就生成一个新的
    e ? e.getAttribute('style') !== styleStr &amp;&amp; e.setAttribute('style', styleStr) : createDiv()
  }).observe(document.querySelector('#' + nodeId).parentNode, { childList: true })
}

//随机生成指定长度的字符串
function sjs(leng) {
  // 大写字母、小写字母、数字能出现的情况
  var char = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789'
  // 定义一个字符串接收随机生成的字符串
  var chars = ''
  // 遍历长度
  for (var i = 0; i &lt; leng; i++) {
    // chars 的值为char中下标为随机数的值
    // 这个随机数取值是Math.random()  0-1不到1
    // Math.random()*char.length 0-1之间的数*char的长度，生成一个0-char.length之间的数,取整不包含最后一个，但是length长度为最大下标+1，所以不用加一
    //最后用+来拼接
    chars += char.charAt(parseInt(Math.random() * char.length))
  }
  return chars
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[el-table自定义表头内数据不更新的问题]]></title>
        <id>https://liujia12138.github.io/post/el-table-zi-ding-yi-biao-tou-nei-shu-ju-bu-geng-xin-de-wen-ti/</id>
        <link href="https://liujia12138.github.io/post/el-table-zi-ding-yi-biao-tou-nei-shu-ju-bu-geng-xin-de-wen-ti/">
        </link>
        <updated>2021-09-29T06:56:13.000Z</updated>
        <content type="html"><![CDATA[<h3 id="el-table自定义表头使用slotheader数据无法更新">el-table自定义表头，使用slot=&quot;header&quot;数据无法更新</h3>
<p>解决方法：将slot=“header” 改成#header</p>
]]></content>
    </entry>
</feed>