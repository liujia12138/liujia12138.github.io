<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://liujia12138.github.io</id>
    <title>JIA&apos;s blog</title>
    <updated>2023-11-26T10:16:11.443Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://liujia12138.github.io"/>
    <link rel="self" href="https://liujia12138.github.io/atom.xml"/>
    <subtitle>温故而知新</subtitle>
    <logo>https://liujia12138.github.io/images/avatar.png</logo>
    <icon>https://liujia12138.github.io/favicon.ico</icon>
    <rights>All rights reserved 2023, JIA&apos;s blog</rights>
    <entry>
        <title type="html"><![CDATA[如何实现异步加载js]]></title>
        <id>https://liujia12138.github.io/ru-he-shi-xian-yi-bu-jia-zai-js/</id>
        <link href="https://liujia12138.github.io/ru-he-shi-xian-yi-bu-jia-zai-js/">
        </link>
        <updated>2023-10-18T07:23:14.000Z</updated>
        <content type="html"><![CDATA[<ol>
<li>将script标签放到body底部<br>
保证优先加载DOM。严格来说，这种方式不算异步加载，但是这个是最常见的通过改变js加载方式来提升页面性能的方式。</li>
<li>defer属性<br>
通过给script标签设置defer属性，将脚本文件的加载设置为延迟加载，当浏览器遇到带有defer属性的script标签时，会再开启一个线程去下载js文件，同时继续解析HTML文档。</li>
</ol>
<p>等到HTML解析完毕，DOM加载完成后再去执行加载好的js</p>
<p>这种方法只适合用于引入外部js的script标签，可以保证多个js的加载和执行顺序就是页面中写的顺序。</p>
<p>需要注意，用了defer属性的js中不应该使用document.write方法</p>
<ol start="3">
<li>async属性<br>
async属性和defer属性类似，都是会单独开启一个线程去下载js文件。</li>
</ol>
<p>和defer不同的是，async会下载之后立即执行，而不是等到DOM加载完成之后再去执行，所以还有<strong>可能会造成阻塞</strong>。</p>
<p>对于所有带有async属性的script标签，不能像defer一样保证执行顺序，他是哪个文件先加载完就先执行。</p>
<p>async也是执只用于引入外部js文件的script标签，同样也不能使用document.write方法。</p>
<p>当脚本之间有依赖关系时，使用defer，这样可以保证执行的顺序；没有依赖的话使用async</p>
<ol start="4">
<li>动态创建script标签</li>
</ol>
<pre><code class="language-js">(function(){
  var scriptEle = document.createElement(&quot;script&quot;);
  scriptEle.type = &quot;text/javascript&quot;;
  scriptEle.async = true;
  scriptEle.arc = &quot;http://xxxx.xxx.xxx/xx.js&quot;

  var x = document.getElementsByTagName('head')[0]
  x.insertBefore(scriptEle, x.firstChild)
})()
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[如何在vue项目中用Express做中间层]]></title>
        <id>https://liujia12138.github.io/ru-he-zai-vue-xiang-mu-zhong-yong-express-zuo-zhong-jian-ceng/</id>
        <link href="https://liujia12138.github.io/ru-he-zai-vue-xiang-mu-zhong-yong-express-zuo-zhong-jian-ceng/">
        </link>
        <updated>2022-10-24T09:50:20.000Z</updated>
        <content type="html"><![CDATA[<p>背景：在已有的vue2项目中，需要进行BFF开发，进行数据聚合和接口转发。为便于代码管理，将Express项目和前端放在一个代码仓库内，不进行拆分。</p>
<h3 id="一-在项目根目录下新建server目录并进入到server目录内">一、在项目根目录下新建server目录，并进入到server目录内</h3>
<h3 id="二-初始化项目">二、初始化项目</h3>
<h4 id="1初始化">1.初始化</h4>
<p><code>npm init</code><br>
为了避免依赖会有版本冲突，Express单独维护自己的node_modules</p>
<h4 id="2安装express">2.安装express</h4>
<p><code>npm i express --save</code></p>
<h4 id="3安装typescript">3.安装typescript</h4>
<p>安装typescript、ts-node（用来监听ts文件的变化并更新服务），node和express的声明文件@types/node @types/express<br>
<code>npm i typescript ts-node @types/express @types/node -D</code></p>
<h4 id="4-ts环境配置">4. ts环境配置</h4>
<p>新建tsconfig.json文件</p>
<pre><code class="language-json">{
        // 指定需要编译文件 否则默认当前目录下除了exclude之外的所有.ts, .d.ts,.tsx 文件
        &quot;include&quot;:[&quot;app.ts&quot;],
        &quot;compilerOptions&quot;: {
            // 指定使用的模块 ：commonjs amd system cmd  or es2015
            &quot;module&quot;: &quot;commonjs&quot;,
              /* 注意：如果未指定--lib，则会注入默认的librares列表。注入的默认库为：
                对于 --target ES5: DOM,ES5,ScriptHost
                对于 --target ES6: DOM,ES6,DOM.Iterable,ScriptHost
                TS 绝不会在您的代码中注入polyfill,所以需要你自己制定编译lib */
            &quot;lib&quot;: [&quot;ESNext&quot;],
             // 指定 ECMAScript 目标版本: 'ES3' (default), 'ES5', 'ES2015', 'ES2016'，'ES2017', or 'ESNEXT'
            &quot;target&quot;: &quot;ES6&quot;,
            // 编译输入文件存放的目录
            &quot;outDir&quot;: &quot;build&quot;,
            // 是否生成.map文件
            &quot;sourceMap&quot;: true,
            &quot;esModuleInterop&quot;: true,
            &quot;forceConsistentCasingInFileNames&quot;: true,
            &quot;strict&quot;: true,
            /* Strict Type-Checking Options */
            // 严格模式将会打开下面的几个选项
            &quot;strict&quot;: false, 
            /* 不允许变量或函数参数具有隐式any类型,例如
            function(name) {
                return name;
            } */
            &quot;noImplicitAny&quot;: true,
            // null类型检测,const teacher: string = null;会报错
            &quot;strictNullChecks&quot;: true,
            // 对函数参数进行严格逆变比较
            &quot;strictFunctionTypes&quot;: true,
            // 严格检查bind call apply
            &quot;strictBindCallApply&quot;: true,
            // 此规则将验证构造函数内部初始化前后已定义的属性。
            &quot;strictPropertyInitialization&quot;: true,
            // 检测this是否隐式指定
            &quot;noImplicitThis&quot;: true,
            // 使用js的严格模式,在每一个文件上部声明 use strict
            &quot;alwaysStrict&quot;: true,
            /* Additional Checks */
            // 默认false,是否检测定义了但是没使用的变量
            &quot;noUnusedLocals&quot;: true,
            // 用于检查是否有在函数体中没有使用的参数
            &quot;noUnusedParameters&quot;: true,
            // 用于检查函数是否有返回值，设为true后，如果函数没有返回值则会提示
            &quot;noImplicitReturns&quot;: true,
            // 用于检查switch中是否有case没有使用break跳出switch
            &quot;noFallthroughCasesInSwitch&quot;: true,
        }
}
</code></pre>
<h3 id="5-新建controller目录用来管理路由">5. 新建controller目录，用来管理路由</h3>
<p>创建article.ts文件，定义文章相关的路由</p>
<pre><code class="language-js">import express from 'express'
import {Response, Request} from 'express'

const router = express.Router()

// 文章分类列表
// 路由处理函数一般会有读写数据库的操作，一般会抽离出来，单独在service目录下管理
router.get('/cates/list', function(req:Request, res:Response)=&gt;{
    // do something
    res.send({
        code: 0,
        msg: 'success',
        data:[]
    })
})

export default router
</code></pre>
<h4 id="6-server目录下新建入口文件-appts">6. server目录下新建入口文件 app.ts</h4>
<pre><code class="language-js">import express from 'express'
import articleRouter from './controller/artcate''
import mw from './middleware'

const app = express()

app.use('/article', articleRouter)

// 错误级别中间件
app.use(mw.errorHandler)

app.listen(3007, () =&gt; {
  console.log('api server is running at http://127.0.0.1:3007')
})
</code></pre>
<h4 id="7packagejson中新增启动脚本">7.package.json中新增启动脚本</h4>
<pre><code class="language-js">&quot;script&quot;:{
    &quot;dev&quot;: &quot;nodemon app.ts&quot;
}
</code></pre>
<p>此时运行<code>npm run dev</code>，在postman中就可以正常请求/article/cates/list 接口了</p>
<h3 id="三-公共配置">三、公共配置</h3>
<h4 id="1-日志输出">1. 日志输出</h4>
<p>安装pino和dayjs<br>
<code>npm i pino pino-pretty dayjs --save</code><br>
<code>npm i @types/pino -D</code></p>
<p>异常监控 Sentry</p>
<h4 id="2-统一响应参数">2. 统一响应参数</h4>
<p>新建const目录，用于存放常量。在const目录下新建code.ts用于存放相应参数，包括status、code和message</p>
<pre><code class="language-js">export enum HTTP_CODE {
  SUCCESS = 0,
  BAD_REQUEST = 400,
  UNAUTHORIZED = 401,
  NOT_FOUND = 404,
  BAD_SERVER = 500,
  NOT_IMPLEMENTED = 501,
  BAD_GATEWAY = 502,
  UNAVAILABLE = 503
}

export enum CODE_MESSAGE {
  SUCCESS = 'success',
  BAD_REQUEST = 'BAD_REQUEST',
  UNAUTHORIZED = '未授权',
  NOT_FOUND = '404',
  BAD_SERVER = '请求异常',
  NOT_IMPLEMENTED = 'NOT_IMPLEMENTED',
  BAD_GATEWAY = 'BAD_GATEWAY',
  UNAVAILABLE = 'UNAVAILABLE'
}

// 状态类型 只能是Code中所枚举的状态
export type CODE_TYPE = keyof typeof HTTP_CODE
</code></pre>
<p>utils目录下新建commonRes.ts ，对响应进行统一处理</p>
<pre><code class="language-js">import { Console } from 'console'
import { Response } from 'express'
import { HTTP_CODE, CODE_MESSAGE, CODE_TYPE } from '../common/const/code'
import logger from './logger'

interface ResOption {
  type?: CODE_TYPE
  message?: string
  status?: number
}

// 默认成功响应
function commonRes(res: Response, data: any, options?: ResOption) {
  options = Object.assign({ type: HTTP_CODE[0] }, options || {}) // 默认success

  const { type, status, message } = options

  let resStatus = status

  if (resStatus === undefined) {
    // 根据状态设置状态码
    resStatus = type === HTTP_CODE[3000] ? 200 : 409
  }

  // 响应参数
  const sendRes: { code: number; data: any; message?: string } = {
    code: HTTP_CODE[type as CODE_TYPE],
    data
  }

  // 响应描述
  message &amp;&amp; (sendRes.message = message)

  return res.status(resStatus).send(sendRes)
}

// 错误响应
commonRes.error = function (
  res: Response,
  data: unknown,
  status: number,
  message?: unknown
) {
  const type = HTTP_CODE[status]
  const msg = message || (CODE_MESSAGE[type] as string)

  logger.error(msg)

  this(res, data, {
    type: type,
    message: msg,
    status: status
  })
}

// 无权限响应
commonRes.denied = function (res: Response, data: unknown) {
  this(res, data, {
    type: 'UNAUTHORIZED',
    message: CODE_MESSAGE['UNAUTHORIZED'],
    status: 401
  })
}

export default commonRes

</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[如何优化webpack配置]]></title>
        <id>https://liujia12138.github.io/ru-he-you-hua-webpack-pei-zhi/</id>
        <link href="https://liujia12138.github.io/ru-he-you-hua-webpack-pei-zhi/">
        </link>
        <updated>2022-10-18T13:04:57.000Z</updated>
        <content type="html"><![CDATA[<p>优化webpack配置可以从两个角度着手，构建速度和构建物体积</p>
<h2 id="一-优化构建速度">一、优化构建速度</h2>
<h3 id="1-安装speed-measure-webpack-plugin插件">1. 安装speed-measure-webpack-plugin插件</h3>
<p>通过speed-measure-webpack-plugin插件来分析每个loader、plugin消耗的打包时间</p>
<pre><code class="language-js">const SpeedMeasurePlugin = require('speed-measure-webpack-plugin')
const smp = new SpeedMeasurePlugin()
</code></pre>
<p>然后用<code>smp.wrap()</code>包裹webpack配置<br>
注意，如果是用vue-cli构建的项目，要在vue.config.js文件中的configureWebpack用<code>smp.wrap()</code>包裹住webpack配置<br>
<img src="https://liujia12138.github.io/post-images/1666320566092.jpg" alt="" loading="lazy"></p>
<h3 id="2-配置happypack">2. 配置happyPack</h3>
<p>在webpack构建过程中，实际上耗费的时间大多是在loader的解析转换及代码的压缩中。日常开发中我们需要用loader对css、图片、文字等文件做转换和解析的操作，并且转换的文件数据量也非常大。但是由于js天生是单线程的，不能够并发处理这些文件。<br>
<em>happyPack</em> 的作用就是将这些任务分解到多个子进程中去并行处理，子进程处理完后把结果发送到主进程，从而减少总的构建时间</p>
<ol>
<li>安装happypack <code>npm i happypack -D</code></li>
<li>配置</li>
</ol>
<pre><code class="language-js">const HappyPack = require('happypack')
module.exports = {
    // ....
    chainWebpack:(config)=&gt;{
        // 配置loader
        const hRule = config.module.rule('js')
        hRule
        .test(/\.js$/)
        .include.add(resolve('src'))
        .end()
        .uses.clear().end()
        .use('happypack/loader?id=js')
        .loader('happypack/loader?id=js')
        .end()
    },
    configureWebpack:()=&gt;{
        return {
            plugins:[
                // 添加plugin，并开启缓存
                new HappyPack({
                    id: 'js',
                    loaders: ['babel-loader?cacheDirectory=true']
                }),
            ]
        }
    }
}
</code></pre>
<p>通过使用happypack，构建时间由原来的23s降到了11s<br>
<img src="https://liujia12138.github.io/post-images/1666333560180.jpg" alt="" loading="lazy"></p>
<h3 id="3-通过设置路径别名来缩小文件的搜索范围">3. 通过设置路径别名来缩小文件的搜索范围</h3>
<h3 id="4-设置loaders的include和exclude-缩小loader编译的范围">4. 设置loaders的include和exclude 缩小loader编译的范围</h3>
<h3 id="5-extenals结合cdn">5. extenals结合cdn</h3>
<p>用cdn的方式来引入一些依赖，并且设置externals来让webpack在打包的时候忽略掉这些依赖。</p>
<h2 id="二-优化构建物体积">二、优化构建物体积</h2>
<h3 id="1-通过配置webpack-bundle-analyzer-来分析打包后的文件">1. 通过配置webpack-bundle-analyzer 来分析打包后的文件</h3>
<p>webpack-bundle-analyzer会将打包后的内容树展示为树状图，让我们能够方便直观的看到打包后的文件内容和体积大小</p>
<pre><code class="language-js">const BundleAnalyzerPlugin = require('webpack-bundle-analyzer')

module.exports = {
    plugins: [
        new BundleAnalyzerPlugin({
            analyzerHost: '127.0.0.1',
            analyzerPort: 8899
        })
    ]
}
</code></pre>
<p>package.json中加入scripts<code>&quot;analyzer&quot;: &quot;NODE_ENV=production npm_config_report=true npm run build&quot;</code></p>
<h3 id="2-tree-shaking-去掉项目中的无用代码">2. tree-shaking 去掉项目中的无用代码</h3>
<p>目前webpack4.x开始，就已经在mode为production时默认开启了tree-shaking，但是如果想要生效，生成的代码必须是es6模块，不能使用其他类型的模块，如commonjs<br>
修正方法，在.babelrc文件或者webpack.config.js设置module:false<br>
vue-cli构建的项目默认开启了tree-shaking，无需单独配置</p>
<h3 id="3">3.</h3>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[vue中keep-alive的原理]]></title>
        <id>https://liujia12138.github.io/vue-zhong-keep-alive-de-yuan-li/</id>
        <link href="https://liujia12138.github.io/vue-zhong-keep-alive-de-yuan-li/">
        </link>
        <updated>2022-09-26T08:43:42.000Z</updated>
        <content type="html"><![CDATA[<h3 id="1-keep-alive是什么">1. keep-alive是什么？</h3>
<p>keep-alive是一个抽象组件，他本身不会渲染成一个dom元素，也不会出现在父组件的链式调用中。<br>
keep-alive可以在切换组件时，保存他所包裹的组件的状态，使其不被销毁。</p>
<p>使用场景：<br>
通常在项目中使用标签页切换路由组件这种情况下，我们从列表页点击【修改】某个数据项时，通过系统内打开标签页的方式打开编辑页，进行一些操作后，我们又切回了列表页，我们希望可以保留编辑页内刚刚的操作，这时使用keep-alive就可以解决这种场景。<br>
keep-alive除了可以保存组件状态，还可以避免组件被反复创建和渲染，可以有效提升系统性能。</p>
<h3 id="2-keep-alive的用法">2. keep-alive的用法</h3>
<p>keep-alive对外提供了三个属性，include/exclude/max 。两个生命周期，activated/deactivated。<br>
include：对哪些进行缓存<br>
exclude：对哪些不进行缓存<br>
max：最多缓存多少个</p>
<h3 id="3-源码解析">3. 源码解析</h3>
<pre><code class="language-js">export default{
	name:'keep-alive',

	abstract:true, //判断当前组件虚拟dom是否渲染成真实dom的关键

	props:{
		include:patternTypes, //缓存白名单
		exclude：patternTypes, //缓存黑名单
		max:[string,number], //混存的组件实例数量上限
	},

	created(){
		this.cache = Object.create(null) //缓存虚拟dom
		this.keys = [] //缓存的虚拟dom的键集合
	},

	destroyed(){
		for(const key in this.cache){ //删除所有缓存
			pruneCachEntry(this.cache,key,this.keys)
		}
	},

	mounted(){
		// &lt;!-- 实时监听黑白名单的变动 --&gt;
		this.$watch('include',val =&gt; {
			pruneCache(this,name =&gt; matches(val,name))
		})

		this.$watch('exclude',val =&gt; {
			pruneCache(this,name =&gt; matches(val,name))
		})
	},

	render(){
		const slot = this.$slots.default
		const vnode:VNode = getFirstComponentChild(slot); //找到第一个子组件对象
		const componentOptions:?VNodeComponentOptions = vnode &amp;&amp; vnode.componentOptions

		if(componentOptions){ //存在组件参数
			&lt;!-- check pattern --&gt;
			const name:?string = getComponent(componentOptions) //组件名称
			const {include,exclude} = this;

			&lt;!-- 条件匹配 --&gt;
			if((include &amp;&amp; (!name || !matches(include,name))) || (exclude &amp;&amp; name &amp;&amp; matches(exclude,name))){
				return vnode
			}


			const {cache ,keys} = this;

			&lt;!-- 定义组件的缓存key --&gt;
			const key:?string = vnode.key == null  ？ componentOptions.Ctor.cid + (componentOptions.tag ? `::${componentOptions.tag}`) : vnode.key

			&lt;!-- 已经缓存过的组件 --&gt;
			if(cache[key]){
				vnode.componentInstance = cache[key].componentInstance
				remove(keys,key)
				keys.push(key) //调整key排序
			}else{
				cache[key] = vnode //缓存组件对象
				keys.push(key)

				if(this.max &amp;&amp; keys.length &gt; parseInt(this.max)){ //超过缓存数限制，将第一个删除
					pruneCacheEntry(cache,keys[0],keys,this._vnode)
				}
			}
		}
	vnode.data.keepAlive = true //渲染和执行被包裹组件的钩子函数需要用到
	}

	return vnode || (slot &amp;&amp; slot[0])
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[如何做到执行JS 而不影响页面的css加载？]]></title>
        <id>https://liujia12138.github.io/ru-he-zuo-dao-zhi-xing-js-er-bu-ying-xiang-ye-mian-de-css-jia-zai/</id>
        <link href="https://liujia12138.github.io/ru-he-zuo-dao-zhi-xing-js-er-bu-ying-xiang-ye-mian-de-css-jia-zai/">
        </link>
        <updated>2022-09-26T07:34:38.000Z</updated>
        <content type="html"><![CDATA[<h4 id="加载js为什么会影响css的加载">加载JS为什么会影响CSS的加载？</h4>
<p>因为js是单线程的，所以当js的加载在css前时，会导致css加载被阻塞，造成UI渲染的卡顿。</p>
<h4 id="什么是web-worker">什么是Web Worker</h4>
<p>web worker的作用就是为JavaScript创造一个多线程的环境，允许主线程创建worker线程，将一个任务分配给worker线程运行。在主线程运行的同时，worker线程在后台运行，两者互不干扰。</p>
<h4 id="如何使用web-worker">如何使用Web Worker</h4>
<h5 id="1-使用web-worker需要注意的点">1. 使用web worker需要注意的点：</h5>
<pre><code>1. 同源限制：分配给Worker线程运行的脚本文件，必须与主线程的脚本文件同源
2. DOM限制：Worker线程所在的全局对象无法读取主线程所在网页的DOM对象，也无法使用DOM的相关API，但是Worker线程可以使用navigator和location对象
3. 通信联系：Worker线程和主线程不在同一个上下文环境，所以无法直接通信，需要使用postMessage
4.  脚本限制：Worker线程不能执行alert方法和confirm方法，但是可以使用XMLHttpRequest发起请求
5.  文件限制：worker无法读取本地文件，他所加载的文件必须来自网络
</code></pre>
<h5 id="2-基本用法">2. 基本用法</h5>
<ol>
<li>
<p>创建一个Worker线程，主线程使用new关键字调用Worker构造函数<br>
<code>var worker = new Worker('work.js')</code><br>
Worker构造函数的参数是一个脚本文件，该文件的内容就是Worker线程要执行的任务。由于worker不能读取本地文件，所以这个文件必须来自网络。</p>
</li>
<li>
<p>主线程向worker线程发消息<br>
主线程调用worker.postMessage方法，向Worker发消息</p>
<pre><code class="language-js">worker.postMessage({method:'echo', args:['work']})
</code></pre>
</li>
<li>
<p>worker线程内 接收/发送 消息<br>
通过监听message事件和postMessage方法</p>
<pre><code class="language-js">// self代表worker子线程自身
self.addEventListener('message', function(e){
   // e.data 可以获取到主线程发送的数据

   self.postMessage('send some message')
})
</code></pre>
</li>
<li>
<p>主线程接收worker线程的消息<br>
调用worker的onmessage方法</p>
</li>
</ol>
<pre><code class="language-js">  worker.onmessage = function(event){
      // event.data可以获取到worker发来的数据
      console.log(event.data)
      // do something
  }
</code></pre>
<ol start="5">
<li>关闭worker线程<br>
主线程： <code>worker.terminate()</code><br>
worker线程： <code>self.close()</code></li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[vue打包性能优化]]></title>
        <id>https://liujia12138.github.io/vue2vue-cli4da-bao-xing-neng-you-hua/</id>
        <link href="https://liujia12138.github.io/vue2vue-cli4da-bao-xing-neng-you-hua/">
        </link>
        <updated>2022-09-26T06:09:17.000Z</updated>
        <content type="html"><![CDATA[<h3 id="1-路由懒加载和分模块打包">1. 路由懒加载和分模块打包</h3>
<p>import()+ webpackChunkName</p>
<h3 id="2-开启-gzip-压缩">2. 开启 Gzip 压缩</h3>
<p>安装 CompressionWebpackPlugin，<code>npm i compression-webpack-plugin --save-dev</code><br>
在 vue.config.js 中配置</p>
<pre><code class="language-js">module.exports = {
  // ....
  configureWebpack: (config) =&gt; {
    if (process.env.NODE_ENV === 'production') {
      const CompressionWebpackPlugin = require('compression-webpack-plugin')
      const productionGzipExtensions = ['html', 'js', 'css']
      config.plugins.push(
        new CompressionWebpackPlugin({
          filename: '[path].gz[query]',
          algorithm: 'gzip',
          test: new RegExp('\\.(' + productionGzipExtensions.join('|') + ')$'),
          // 文件大小超过1k才会被压缩
          threshold: 1024,
          minRatio: 0.99,
          // 删除源文件
          deleteOriginAssets: true
        })
      )
    }
  }
}
</code></pre>
<h3 id="3-icon-图片转-base64">3. icon 图片转 base64</h3>
<p>使用 file-loader 和 url-loader</p>
<pre><code class="language-js"> {
    test: /\.(png|jpe?g|gif|svg)(\?.*)?$/,
    loader: &quot;url-loader&quot;,
    exclude: [resolve(&quot;src/assets/icons&quot;)],
    options: {
      limit: 10000,
      name: utils.assetsPath(&quot;img/[name].[hash:7].[ext]&quot;)
    }
  }
</code></pre>
<h3 id="4-使用-cdn">4. 使用 cdn</h3>
<p>（选配，CDN 虽然速度快，但是没有本地打包稳定）</p>
<pre><code>// 是否为生产环境
const isProduction = process.env.NODE_ENV !== 'development';

// 本地环境是否需要使用cdn
const devNeedCdn = false

// cdn链接
const cdn = {
    // cdn：模块名称和模块作用域命名（对应window里面挂载的变量名称）
    externals: {
        vue: 'Vue',
        vuex: 'Vuex',
        'vue-router': 'VueRouter',
        'marked': 'marked',
        'highlight.js': 'hljs',
        'nprogress': 'NProgress',
        'axios': 'axios'
    },
    // cdn的css链接
    css: [
        'https://cdn.bootcss.com/nprogress/0.2.0/nprogress.min.css'
    ],
    // cdn的js链接
    js: [
        'https://cdn.bootcss.com/vue/2.6.10/vue.min.js',
        'https://cdn.bootcss.com/vuex/3.1.2/vuex.min.js',
        'https://cdn.bootcss.com/vue-router/3.1.3/vue-router.min.js',
        'https://cdn.bootcss.com/marked/0.8.0/marked.min.js',
        'https://cdn.bootcss.com/highlight.js/9.18.1/highlight.min.js',
        'https://cdn.bootcss.com/nprogress/0.2.0/nprogress.min.js',
        'https://cdn.bootcss.com/axios/0.19.2/axios.min.js'
    ]
}

module.exports = {
    chainWebpack: config =&gt; {
        // ============注入cdn start============
        config.plugin('html').tap(args =&gt; {
            // 生产环境或本地需要cdn时，才注入cdn
            if (isProduction || devNeedCdn) args[0].cdn = cdn
            return args
        })
        // ============注入cdn start============
    },
    configureWebpack: config =&gt; {
        // 用cdn方式引入，则构建时要忽略相关资源
        if (isProduction || devNeedCdn) config.externals = cdn.externals
    }
}
</code></pre>
<p>html 中引入 CDN</p>
<pre><code class="language-html">&lt;!-- 使用CDN的CSS文件 --&gt;
&lt;% for (var i in htmlWebpackPlugin.options.cdn &amp;&amp; htmlWebpackPlugin.options.cdn.css) { %&gt;
&lt;link href=&quot;&lt;%= htmlWebpackPlugin.options.cdn.css[i] %&gt;&quot; rel=&quot;stylesheet&quot; /&gt;
&lt;% } %&gt;
&lt;!-- 使用CDN的CSS文件 --&gt;

&lt;!-- 使用cdn的js文件 --&gt;
&lt;% for (var i in htmlWebpackPlugin.options.cdn &amp;&amp; htmlWebpackPlugin.options.cdn.js) { %&gt;
&lt;script src=&quot;&lt;%= htmlWebpackPlugin.options.cdn.js[i] %&gt;&quot;&gt;&lt;/script&gt;
&lt;% } %&gt;
&lt;!-- 使用CDN的js文件 --&gt;
</code></pre>
<h3 id="5-压缩-js-代码">5. 压缩 js 代码</h3>
<p>使用 UglifyjsWebpackPlugin 插件</p>
<ol>
<li>安装``` npm i uglifyjs-webpack-plugin --save-dev ````</li>
<li>在 vue.config.js 中引入</li>
</ol>
<pre><code class="language-js">module.exports = {
  configureWebpack: (config) =&gt; {
    const UglifyjsWebpackPlugin = require('uglifyjs-webpack-plugin')
    config.plugins.push(
      new UglifyjsWebpackPlugin({
        uglifyOptions: {
          // 生产环境自动删除console
          compress: {
            drop_debugger: true,
            drop_console: true,
            pure_funcs: ['console.log']
          }
        },
        sourceMap: false,
        parallel: true
      })
    )
  }
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[JS的作用域、预解析和声明提升]]></title>
        <id>https://liujia12138.github.io/js-de-zuo-yong-yu-yu-jie-xi-he-sheng-ming-ti-sheng/</id>
        <link href="https://liujia12138.github.io/js-de-zuo-yong-yu-yu-jie-xi-he-sheng-ming-ti-sheng/">
        </link>
        <updated>2022-09-18T07:28:18.000Z</updated>
        <content type="html"><![CDATA[<h3 id="作用域">作用域</h3>
<p>作用域就是变量的有效范围。 在一定的空间里可以对数据进行读写操作，这个空间就是数据的作用域</p>
<h4 id="1-全局作用域">1、全局作用域：</h4>
<p>最外层函数定义的变量拥有全局作用域，即对任何内部函数来说，都是 可以访问的；</p>
<h4 id="2-局部作用域">2、局部作用域：</h4>
<p>局部作用域一般只在固定的代码片段内可访问到，而对于函数外部是无 法访问的，最常见的例如函数内部。在 ES6 之前，只有函数可以划分变量的作用域，所以 在函数的外面无法访问函数内的变量</p>
<h4 id="3-块级作用域">3、块级作用域：</h4>
<p>凡是代码块就可以划分变量的作用域，这种作用域的规则就叫块级作用域</p>
<h4 id="块级作用域-函数作用域-词法作用域之间的区别">块级作用域 函数作用域 词法作用域之间的区别：</h4>
<p>3.1）块级作用域和函数作用域描述的是，什么东西可以划分变量的作用域<br>
3.2）词法作用域描述的是，变量的查找规则<br>
之间的关系：<br>
1、 块级作用域 包含 函数作用域<br>
2、 词法作用域 与 块级作用域、函数作用域之间没有任何交集， 他们从两个角度描述了作用域的规则<br>
ES6 之前 JavaScript 采用的是函数作用域+词法作用域，ES6 js 采用的是块级作用域+词法作用域</p>
<h3 id="预解析">预解析</h3>
<p>JavaScript 代码的执行是由浏览器中的 JavaScript 解析器来执行的。JavaScript 解析器执行 JavaScript 代码的时候，分为两个过程：预解析过程和代码执行过程</p>
<h4 id="预解析过程都发生了什么">预解析过程都发生了什么？</h4>
<ol>
<li>将变量的声明提升到作用域的最前面，只会提升声明，不会提升赋值。</li>
<li>将函数的声明提升到作用域的最前面，只会提升声明，不会提升调用。</li>
<li>函数提升的优先级大于变量提升的优先级</li>
</ol>
<pre><code class="language-js">// 因为var先提升，所以此处的fn是函数fn
console.log(fn);// [Function: fn]
function fn (){
  return 'fn'
}
var fn = 'aaa'
</code></pre>
<h3 id="声明提升">声明提升</h3>
<p>如上面代码，使用var关键字声明的变量，或者使用函数声明创建的函数，可以先使用后声明。<br>
需要注意的是，使用函数表达式的写法创建的函数，不会存在声明提升</p>
<pre><code class="language-js">// 函数表达式
var fn = function(){
    return 'fn'
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[js中如何判断两个对象是否相等]]></title>
        <id>https://liujia12138.github.io/js-zhong-ru-he-pan-duan-liang-ge-dui-xiang-shi-fou-xiang-deng/</id>
        <link href="https://liujia12138.github.io/js-zhong-ru-he-pan-duan-liang-ge-dui-xiang-shi-fou-xiang-deng/">
        </link>
        <updated>2022-09-18T03:30:26.000Z</updated>
        <content type="html"><![CDATA[<h4 id="1-判断两个对象的引用地址">1、判断两个对象的引用地址</h4>
<p>ES6中，提供了一个方法可以用来判断两个对象的引用地址是否一致：<code>Object.is(value1, value2)</code>。返回值为一个布尔值，如果两个对象引用地址一致则返回值为true，反之则为false</p>
<p>####2、判断两个对象内容一致<br>
想要比较两个对象的内容是否一致，需要遍历对象所有的键名和键值，判断是否完全一致。<br>
实现思路：<br>
1. 先判断两个对象引用地址是否一致<br>
2. 获取对象所有键名的数组，并且判断长度是否一致<br>
3. 遍历键名数组，判断键值是否都相等</p>
<pre><code class="language-js">function isObjectValueEqual(obj1, obj2){
    // 1.判断引用地址是否一致，一致则直接返回true
    if(Object.is(obj1, obj2)) return true
    const props1 = Object.getOwnPropertyNames(obj1)
    const props2 = Object.getOwnPropertyNames(obj2)
    // 2.判断键名数组长度是否一致，不一致则直接返回false
    if(props1.length !== props2.length) return false;
    // 3.键名数组长度一致，遍历键名数组，判断所有值是否一致
    for(let prop in obj1){
        // 3.1判断obj1的键值在obj2中是否存在，存在则进一步判断值，不存在直接返回false
        if(obj2.hasOwnProperty(prop)){
            // 3.2判断obj1的键值是否为对象，是则递归判断，否则直接判断值是否相等
            if(typeof obj1[prop] === 'object'){
                if(!isObjectValueEqual(obj1[prop],obj2[prop])) return false
            }else{
                if(obj1[prop] !== obj2[prop]) return false
            }
        }else{
            return false
        }
    }
    return true
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[JavaScript的内置对象、原生对象、宿主对象分别指的是什么？]]></title>
        <id>https://liujia12138.github.io/javascript-de-nei-zhi-dui-xiang-yuan-sheng-dui-xiang-su-zhu-dui-xiang-fen-bie-zhi-de-shi-shi-me/</id>
        <link href="https://liujia12138.github.io/javascript-de-nei-zhi-dui-xiang-yuan-sheng-dui-xiang-su-zhu-dui-xiang-fen-bie-zhi-de-shi-shi-me/">
        </link>
        <updated>2022-09-18T02:48:46.000Z</updated>
        <content type="html"><![CDATA[<h3 id="1-内置对象">1、内置对象</h3>
<p>由ECMAScript实现提供的、独立于宿主环境的所有对象。<br>
内置对象在引擎初始化阶段就已经被创建好。<br>
ECMA-262只定义了两个内置对象，即Global和Math。他们也是本地对象，即内置对象其实是本地对象的一种。</p>
<h3 id="2-原生对象">2、原生对象</h3>
<p>ECMA-262将本地对象定义为独立于宿主环境的ECMAScript实现提供对象。<br>
除了内置对象外，原生对象还包括了一些在运行过程中创建的对象。<br>
本地对象包括：Object、Function、Array、String、Number、Boolean、Date、RegExp、Error、EvalError、RangeError、ReferenceError、SyntaxError、TypeError、URLError<br>
由此可以看出，本地对象就是ECMA定义的类。</p>
<h3 id="3-宿主对象">3、宿主对象</h3>
<p>ECMAScript中的宿主就是我们网页所运行的环境，即浏览器和操作系统。<br>
所有的非本地对象都是宿主对象，即由ECMAScript实现的宿主环境提供的对象。<br>
所有的DOM和BOM都是宿主对象。因为其对于不同的宿主环境所展示的内容是不一样的。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[react 和 vue 中的 key 有什么作用？]]></title>
        <id>https://liujia12138.github.io/react-he-vue-zhong-de-key-you-shi-me-zuo-yong/</id>
        <link href="https://liujia12138.github.io/react-he-vue-zhong-de-key-you-shi-me-zuo-yong/">
        </link>
        <updated>2022-09-13T03:30:44.000Z</updated>
        <content type="html"><![CDATA[<h5 id="一-虚拟-dom-中-key-的作用">一. 虚拟 DOM 中 key 的作用：</h5>
<p>key 是虚拟 DOM 中对象的标识，当数据发生变化时，vue 会根据 新数据 生成 新的虚拟 DOM，随后 Vue 内部会进行 新虚拟 DOM 和 旧的虚拟 DOM 的差异对比（diff 算法）：</p>
<h6 id="对比规则">对比规则：</h6>
<ol>
<li>旧的虚拟 DOM 中找到与新的虚拟 DOM 中具有相同 key 值的 VNode</li>
</ol>
<ul>
<li>若虚拟 DOM 中内容没有发生变化，直接使用 之前的真实DOM，不会改变DOM</li>
<li>若虚拟 DOM 中内容发生了变化，则生成新的真实 DOM，随后替换掉页面中之前的真实 DOM</li>
</ul>
<ol start="2">
<li>旧的虚拟 DOM 中没有找到与新的虚拟 DOM 具有相同 key 值的 VNode<br>
创建新的真实 DOM，然后渲染到页面上</li>
</ol>
<h5 id="二-用-index-作为-key-值可能会引发的问题">二. 用 index 作为 key 值可能会引发的问题？</h5>
<ol>
<li>若对数据进行：逆序添加、逆序删除等破坏原有顺序的操作，会产生没有必要的真实 DOM 更新，页面效果没有问题，但是效率低（因为对数据的顺序进行了改变，导致没有发生变化的数据在渲染时也无法使用之前的真实DOM）</li>
<li>如果结构中还包含了输入类的 DOM，如 input，会产生错误的 DOM 更新，导致页面有问题，如：</li>
</ol>
<pre><code class="language-html">&lt;template&gt;
  &lt;div&gt;
    &lt;button @click=&quot;addPerson&quot;&gt;向列表前添加一个人&lt;/button&gt;
    &lt;ul&gt;
      &lt;li v-for=&quot;(item,index) in persons&quot; :key=&quot;index&quot;&gt;
        {{item.name}}---{{index}}
        &lt;!-- 每人一个输入框 --&gt;
        &lt;input type=&quot;text&quot; /&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
  export default{
    data(){
      return {
        person: [
          {
            name: '张三',
            id: '001'
          },{
            name: '李四',
            id: '002'
          },{
            name: '王五',
            id: '003'
          }
        ]
      }
    },
    methods:{
      addPerson(){
        let p = {
          name: '老刘',
          id: '004
        }
        this.person.upshift(p)
      }
    }
  }
&lt;/script&gt;
</code></pre>
<p>页面渲染出persons列表后在每行的input中输入姓名<br>
效果图:<br>
<img src="https://liujia12138.github.io/post-images/1663040035727.jpg" alt="" loading="lazy"></p>
<p>点击按钮，添加老刘后<br>
<img src="https://liujia12138.github.io/post-images/1663040050410.jpg" alt="" loading="lazy"></p>
<p>此时页面上老刘数据添加到persons的第一位，姓名和index都正常渲染，但是input出现了错位的情况。<br>
这是因为旧的虚拟DOM中张三和新的虚拟DOM中老刘具有相同的key：0，diff算法在进行差异对比时，发现name不同，然后页面渲染时就会渲染上新的name，但是对于input，由于上一步在input中输入姓名的操作是发生在真实DOM中的，没有影响到虚拟DOM，所以，在进行对比时会认为这一部分没有发生变化，这时页面就会继续使用上一次渲染的input，这也就导致了‘老刘’这条数据在页面上的input是张三的。</p>
<p>对比过程图<br>
<img src="https://liujia12138.github.io/post-images/1663040060872.jpg" alt="" loading="lazy"></p>
<h5 id="三开发中如何选择key">三.开发中如何选择key？</h5>
<ol>
<li>最好使用每条数据的唯一标识作为key，比如id，手机号，身份证号等唯一值</li>
<li>如果不存在对数据逆序添加、逆序删除等破坏顺序的操作，仅用于渲染列表展示，使用index作为key是不会有问题的</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[定时任务时间表达式规则]]></title>
        <id>https://liujia12138.github.io/ding-shi-ren-wu-shi-jian-biao-da-shi-gui-ze/</id>
        <link href="https://liujia12138.github.io/ding-shi-ren-wu-shi-jian-biao-da-shi-gui-ze/">
        </link>
        <updated>2022-08-10T07:05:16.000Z</updated>
        <content type="html"><![CDATA[<h3 id="为什么需要时间表达式">为什么需要时间表达式</h3>
<p>数据中台项目中，需要定时执行规则来进行数据质量的检核，这个定时的规则通常是用户在后台进行配置的。</p>
<h3 id="定时任务时间表达式规则">定时任务时间表达式规则</h3>
<p>时间表达式组件一般由秒、分、时、日、月、周（星期几）、年7个域组成<br>
对应的生成的表达式也是由 s、m、h、d、M、w、y 7个值由空格拼接生成</p>
<h5 id="各个域的含义和可选值">各个域的含义和可选值：</h5>
<table>
<thead>
<tr>
<th>域</th>
<th style="text-align:center">取值</th>
<th>特殊字符</th>
</tr>
</thead>
<tbody>
<tr>
<td>1.秒</td>
<td style="text-align:center">0-59</td>
<td>, - / *</td>
</tr>
<tr>
<td>2.分</td>
<td style="text-align:center">0-59</td>
<td>, - / *</td>
</tr>
<tr>
<td>3.时</td>
<td style="text-align:center">0-23</td>
<td>, - / *</td>
</tr>
<tr>
<td>4.日</td>
<td style="text-align:center">1-31</td>
<td>, - / * ? L W</td>
</tr>
<tr>
<td>5.月</td>
<td style="text-align:center">1-12</td>
<td>, - / *</td>
</tr>
<tr>
<td>6.周</td>
<td style="text-align:center">1-7或SUN-SAT</td>
<td>, - / * ? L</td>
</tr>
<tr>
<td>7.年</td>
<td style="text-align:center">1970-2099</td>
<td>, - / *</td>
</tr>
</tbody>
</table>
<h5 id="特殊字符的含义">特殊字符的含义</h5>
<p>* : 表示匹配该域的任意值。比如Minutes域使用*，就表示每分钟都会触发。<br>
- : 表示范围。比如Minutes域使用 10-20，就表示从10分钟到20分钟每分钟都会触发一次。<br>
, : 表示列出枚举值。比如Minutes域使用1,3，就表示1分钟和3分钟都会触发一次。<br>
/ : 表示间隔时间触发(开始时间/时间间隔)。例如在Minutes域使用 5/10，就表示从第5分钟开始，每隔10分钟触发一次。<br>
? : 表示不指定值。简单理解就是忽略该字段的值，直接根据另一个字段的值触发执行。<br>
# : 表示该月第n个星期x(x#n)，仅用星期域。如：星期：6#3，表示该月的第三个星期五。<br>
L : 表示最后，是单词&quot;last&quot;的缩写（最后一天或最后一个星期几）；仅出现在日和星期的域中。用在日则表示该月的最后一天，用在星期则表示该月的最后一个星期。如：星期域上的值为5L，则表示该月最后一个星期的星期四。在使用'L'时，不要指定列表','或范围'-'，否则易导致出现意料之外的结果。<br>
W: 仅用在日的域中，表示距离当月给定日期最近的工作日（周一到周五），是单词&quot;weekday&quot;的缩写。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[vue+webpack 实现多入口架构]]></title>
        <id>https://liujia12138.github.io/vuewebpack-shi-xian-duo-ru-kou-jia-gou/</id>
        <link href="https://liujia12138.github.io/vuewebpack-shi-xian-duo-ru-kou-jia-gou/">
        </link>
        <updated>2022-05-18T07:12:30.000Z</updated>
        <content type="html"><![CDATA[<h4 id="一-为什么需要多入口多页面项目">一、为什么需要多入口多页面项目？</h4>
<p>vue 项目大多是单页面项目，即一个 main.js 入口文件，一般情况下使用 webpack 默认配置就可以。但是如果项目很大，有很多个小的分项目，比如一个数据处理平台需要包含数据接入、数据处理、数据输出等分项目，这时把这几个分项目合并到一个项目中管理会方便很多。</p>
<h4 id="二-多页面可以解决哪些问题">二、多页面可以解决哪些问题？</h4>
<ul>
<li>独立维护子系统的权限和缓存数据</li>
<li>开发一个子系统时，不需要启动另外一个系统</li>
<li>热更新一个子系统时，不需要编译所有系统</li>
</ul>
<h4 id="三-怎样配置一个-vue-多页面应用">三、怎样配置一个 vue 多页面应用</h4>
<h5 id="1先创建一个-vue-项目">1.先创建一个 vue 项目</h5>
<pre><code>vue init webpack project-name
</code></pre>
<h5 id="2给每个子系统创建-mainjs-appvue-indexhtml-文件最终目录结构如下">2.给每个子系统创建 main.js、App.vue、index.html 文件，最终目录结构如下</h5>
<pre><code>├─build
├─config
├─node_modules
├─src
|  ├─api
|  ├─assets
|  ├─components
|  ├─layout
|  ├─pages
|  |  ├─system1
|  |  | ├─views
|  |  | ├─store
|  |  | ├─router
|  |  |  main.js
|  |  |  index.html
|  |  ├─system2
|  |  | ├─views
|  |  | ├─store
|  |  | ├─router
|  |  |  main.js
|  |  |  index.html
|    ...

</code></pre>
<h5 id="3修改-webpack-配置文件">3.修改 webpack 配置文件</h5>
<p>基础配置 webpack.base.conf.js</p>
<pre><code class="language-js">const glob = require('glob')
const path = require('path')
const HtmlWebpackPlugin = require('html-webpack-plugin')

function resolve(dir) {
  return path.join(__dirname, '..', dir)
}

const entrys = {} //入口文件配置
const pageDir = resolve('src/pages')

const pages = glob.sync('*/index.html', { cwd: pageDir }).map((p) =&gt; {
  const name = p.split('/')[0]
  entrys[name] = `${pageDir}/${name}/main.js`
  return new HtmlWebpackPlugin({
    filename: `${name}.html`,
    template: pageDir + '/' + p,
    chunks: ['manifest', 'vendor', 'app', name],
    inject: true,
    favicon: './static/favicon.ico',
    minify: {
      removeComments: true,
      collapseWhitespace: true,
      removeAttributeQuotes: true
    },
    chunksSortMode: 'dependency'
  })
})

module.exports = {
  context: path.resolve(__dirname, '../'),
  entry: entrys,
  output: {
    path: config.build.assetsRoot,
    filename: '[name].js',
    publicPath: process.env.NODE_ENV === 'production' ? config.build.assetsPublicPath : config.dev.assetsPublicPath
  },
  plugins: [...pages]
  // 其他。。。。
}
</code></pre>
<p>开发环境配置 webpack.dev.conf.js，HtmlWebpackPlugin 已经在基础配置中修改，dev 环境不需要再修改</p>
<p>生产环境配置 webpack.prod.conf.js，修改output</p>
<pre><code class="language-js">modules.exports = {
  // ....
  output: {
    path: config.build.assetsRoot,
    filename: utils.assetsPath('js/[name].[chunkhash].js'),
    chunkFilename: utils.assetsPath('js/[id].[chunkhash].js'),
    publicPath: '/'
  },
  plugins: [
    // 公共模块单独打包
    new webpack.optimize.CommonsChunkPlugin({
      name: 'vendor',
      minChunks(module) {
        return (
          module.resource &amp;&amp;
          /\.js$/.test(module.resource) &amp;&amp;
          module.resource.indexOf(path.join(__dirname, '../node_modules')) === 0
        )
      }
    }),
    new webpack.optimize.CommonsChunkPlugin({
      name: 'manifest',
      minChunks: Infinity
    }),
    new webpack.optimize.CommonsChunkPlugin({
      name: 'app',
      async: 'vendor-async',
      children: true,
      minChunks: 3,
      maxChunks: 10
    })
  ]
}
</code></pre>
<h5 id="4运行项目">4.运行项目</h5>
<pre><code>npm run dev
</code></pre>
<p>http://localhost:8080/system1.html#/home  就可以访问啦</p>
<h5 id="5打包">5.打包</h5>
<pre><code>npm run build
</code></pre>
<p>打包结果</p>
<pre><code>dist
├─system1.html
├─system2.html
├─static
| ├─css
| ├─js
| ├─fonts
| ├─img
| ├─static
└ ├─js
</code></pre>
<h4 id="四-后续优化">四、后续优化</h4>
<p>1.单独构建、打包某个子系统<br>
2.子系统特有依赖模块打包策略</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[eslint+prettier 代码规范自动化配置]]></title>
        <id>https://liujia12138.github.io/eslintprettier-dai-ma-gui-fan-zi-dong-hua-pei-zhi/</id>
        <link href="https://liujia12138.github.io/eslintprettier-dai-ma-gui-fan-zi-dong-hua-pei-zhi/">
        </link>
        <updated>2022-05-10T07:16:22.000Z</updated>
        <content type="html"><![CDATA[<p>Eslint:</p>
<ol>
<li>安装：eslint^6.7.2 eslint-plugin-vue^6.2.2 babel-eslint^10.1.0</li>
<li>安装 vue-cli eslint 插件： @vue/cli-plugin-eslint</li>
<li>scripts 中加入命令： <code>&quot;lint&quot;:&quot;vue-cli-service lint&quot;</code></li>
<li>.eslintrc.js 文件中加入相关配置</li>
<li>.eslintignore 文件中配置忽略的目录及文件</li>
</ol>
<p>Prettier:</p>
<ol>
<li>项目目录下新建.prettierrc.js，并添加相关配置</li>
<li>项目目录下新建.prettierigonre，配置格式化忽略的文件</li>
<li>package.json 中添加命令: <code>&quot;format&quot;:&quot;prettier —write 'src/\*_/_.{js,vue,css,scss}'&quot;</code></li>
<li>运行 <code>npm run format</code> 即可完成项目文件批量格式化</li>
</ol>
<p>prettier 配置：</p>
<pre><code class="language-js">module.exports = {
  printWidth: 140, // 超过最大值换行
  tabWidth: 2,
  useTabs: false,
  semi: false, // 句尾不添加分号
  singleQuote: true, // 使用单引号
  quoteProps: 'as-needed',
  jsxSingleQuote: true,
  trailingComma: 'none',
  bracketSpacing: true, // 在对象，数组括号与文字之间加空格 &quot;{ foo: bar }&quot;
  jsxBracketSameLine: true, // 在jsx中把'&gt;' 是否单独放一行
  arrowParens: 'always', // 箭头函数单个参数省略括号
  insertPragma: false,
  proseWrap: 'preserve',
  htmlWhitespaceSensitivity: 'ignore',
  vueIndentScriptAndStyle: false, // vue script和style标签中是否缩进
  endOfLine: 'auto',
  embeddedLanguageFormatting: 'auto'
}
</code></pre>
<p>eslint 配置</p>
<pre><code class="language-js">module.exports = {
  root: true,
  parserOptions: {
    parser: 'babel-eslint',
    sourceType: 'module'
  },
  env: {
    browser: true,
    node: true,
    es6: true
  },
  extends: ['plugin:vue/recommended', 'eslint:recommended'],

  // add your custom rules here
  // it is base on https://github.com/vuejs/eslint-config-vue
  rules: {
    'vue/max-attributes-per-line': [
      //强制每行的最多属性数
      2,
      {
        singleline: 10, // 单行情况下每行最多十个属性
        multiline: {
          max: 1,
          allowFirstLine: false
        }
      }
    ],
    'vue/html-self-closing': [
      //html标签强制执行自闭式
      'error',
      {
        html: {
          void: 'any',
          normal: 'any',
          component: 'any'
        },
        svg: 'any',
        math: 'any'
      }
    ],
    'vue/singleline-html-element-content-newline': 'off', // 在单行元素的内容前后使用换行符
    'vue/no-parsing-error': [2, { 'invalid-first-character-of-tag-name': false }],
    'vue/no-use-v-if-with-v-for': 1,
    'vue/multiline-html-element-content-newline': 'off', // 在多行元素的内容前后使用换行符
    'vue/name-property-casing': [0, 'PascalCase'],
    'vue/html-closing-bracket-newline': [
      0,
      {
        singleline: 'never',
        multiline: 'always'
      }
    ],
    'vue/no-side-effects-in-computed-properties': 0,
    'accessor-pairs': 2, //在对象中使用getter/setter
    'arrow-spacing': [
      2,
      {
        before: true,
        after: true
      }
    ], //=&gt;的前/后括号
    'block-spacing': [2, 'always'], //块是否需要空格
    // if while function 后面的{必须与if在同一行，java风格。
    'brace-style': [
      2,
      '1tbs',
      {
        allowSingleLine: true
      }
    ],
    //强制驼峰法命名
    camelcase: [
      0,
      {
        properties: 'always'
      }
    ],
    // 数组和对象键值对最后一个逗号， never参数：不能带末尾的逗号, always参数：必须带末尾的逗号，
    // always-multiline：多行模式必须带逗号，单行模式不能带逗号
    'comma-dangle': [2, 'never'],
    // 控制逗号前后的空格
    'comma-spacing': [
      2,
      {
        before: false,
        after: true
      }
    ],
    'comma-style': [2, 'last'], // 控制逗号在行尾出现还是在行首出现
    // 强制在子类构造函数中用super()调用父类构造函数，TypeScrip的编译器也会提示
    'constructor-super': 2,
    // 强制object.key 中 . 的位置，参数:
    // property，'.'号应与属性在同一行
    // object, '.' 号应与对象名在同一行
    'dot-location': [2, 'property'],
    'eol-last': 2, // 文件末尾强制换行
    eqeqeq: [2, 'allow-null'], // 使用 === 替代 ==
    'generator-star-spacing': 0, //生成器函数*的前后空格
    'handle-callback-err': 0, //nodejs 处理错误
    indent: [
      2,
      2,
      {
        //缩进风格
        SwitchCase: 1
      }
    ],
    // JSX 属性中一致使用双引号或单引号
    'jsx-quotes': [2, 'prefer-single'],
    //对象字面量中冒号的前后空格
    'key-spacing': [
      2,
      {
        beforeColon: false,
        afterColon: true
      }
    ],
    'keyword-spacing': [
      2,
      {
        before: true,
        after: true
      }
    ],
    //函数名首行大写必须使用new方式调用，首行小写必须用不带new方式调用
    'new-cap': [
      2,
      {
        newIsCap: true,
        capIsNew: false
      }
    ],
    'new-parens': 2, //new时必须加小括号
    'no-array-constructor': 2, //禁止使用数组构造器
    'no-caller': 2, //禁止使用arguments.caller或arguments.callee
    'no-console': process.env.NODE_ENV === 'production' ? 2 : 0, //禁止使用console
    'no-class-assign': 2, //禁止给类赋值
    'no-cond-assign': 2, //禁止在条件表达式中使用赋值语句
    'no-const-assign': 2, //禁止修改const声明的变量
    'no-control-regex': 0, //禁止在正则表达式中使用控制字符
    'no-delete-var': 2, //不能对var声明的变量使用delete操作符
    'no-dupe-args': 2, //函数参数不能重复
    'no-dupe-class-members': 2, //不允许类中出现重复的声明
    'no-dupe-keys': 2, //在创建对象字面量时不允许键重复 {a:1,a:1}
    'no-duplicate-case': 2, //switch中的case标签不能重复
    'no-empty-character-class': 0, //正则表达式中的[]内容不能为空
    'no-empty-pattern': 0,
    'no-eval': 0, //禁止使用eval
    'no-ex-assign': 2, //禁止给catch语句中的异常参数赋值
    'no-extend-native': 2, //禁止扩展native对象
    'no-extra-bind': 2, //禁止不必要的函数绑定
    'no-extra-boolean-cast': 2, //禁止不必要的bool转换
    'no-extra-parens': [2, 'functions'], //禁止非必要的括号
    'no-fallthrough': 2, //禁止switch穿透
    'no-floating-decimal': 2, //禁止省略浮点数中的0 .5 3.
    'no-func-assign': 2, //禁止重复的函数声明
    'no-implied-eval': 2, //禁止使用隐式eval
    'no-inner-declarations': [2, 'functions'], //禁止在块语句中使用声明（变量或函数）
    'no-invalid-regexp': 2, //禁止无效的正则表达式
    'no-irregular-whitespace': 2, //不能有不规则的空格
    'no-iterator': 2, //禁止使用__iterator__ 属性
    'no-label-var': 2, //label名不能与var声明的变量名相同
    'no-labels': [
      2,
      {
        //禁止标签声明
        allowLoop: false,
        allowSwitch: false
      }
    ],
    'no-lone-blocks': 2, //禁止不必要的嵌套块
    'no-mixed-spaces-and-tabs': 2, //禁止混用tab和空格
    'no-multi-spaces': 2, //不能用多余的空格
    'no-multi-str': 2, //字符串不能用\换行
    'no-multiple-empty-lines': [
      0,
      {
        max: 1
      }
    ], //空行最多不能超过1行
    'no-native-reassign': 2, //不能重写native对象
    'no-negated-in-lhs': 2, //in 操作符的左边不能有!
    'no-new-object': 2, //禁止使用new Object()
    'no-new-require': 2, //禁止使用new require
    'no-new-symbol': 2, //禁止使用new symbol
    'no-new-wrappers': 2, //禁止使用new创建包装实例，new String new Boolean new Number
    'no-obj-calls': 0, //不能调用内置的全局对象，比如Math() JSON()
    'no-octal': 2, //禁止使用八进制数字
    'no-octal-escape': 2, //禁止使用八进制转义序列
    'no-path-concat': 2, //node中不能使用__dirname或__filename做路径拼接
    'no-proto': 2, //禁止使用__proto__属性
    'no-redeclare': 2, //禁止重复声明变量
    'no-regex-spaces': 2, //禁止在正则表达式字面量中使用多个空格 /foo bar/
    'no-return-assign': [2, 'except-parens'], //return 语句中不能有赋值表达式
    'no-self-assign': 2, //自我分配
    'no-self-compare': 2, //不能比较自身
    'no-sequences': 2, //禁止使用逗号运算符
    'no-shadow-restricted-names': 2, //严格模式中规定的限制标识符不能作为声明时的变量名使用
    'no-spaced-func': 2, //函数调用时 函数名与()之间不能有空格
    'no-sparse-arrays': 2, //禁止稀疏数组， [1,,2]
    'no-this-before-super': 2, //在调用super()之前不能使用this或super
    'no-throw-literal': 2, //禁止抛出字面量错误 throw &quot;error&quot;;
    'no-trailing-spaces': 0, //一行结束后面不要有空格
    'no-undef': 2, //不能有未定义的变量
    'no-undef-init': 2, //变量初始化时不能直接给它赋值为undefined
    'no-unexpected-multiline': 0, //避免多行表达式
    'no-unmodified-loop-condition': 0, //检查引用是否在循环中被修改
    'no-unneeded-ternary': 0, //禁止不必要的嵌套 var isYes = answer === 1 ? true : false;
    'no-unreachable': 2, //不能有无法执行的代码
    'no-unsafe-finally': 0,
    'no-unused-vars': [
      2,
      {
        vars: 'all',
        args: 'none'
      }
    ], //不能有声明后未被使用的变量或参数
    'no-useless-call': 2, //禁止不必要的call和apply
    'no-useless-computed-key': 0, //没有必要使用带文字的计算属性
    'no-useless-constructor': 2, //可以在不改变类的工作方式的情况下安全地移除的类构造函数
    'no-useless-escape': 0,
    'no-whitespace-before-property': 0,
    'no-with': 2, //禁用with
    'one-var': 0, //连续声明
    'operator-linebreak': [
      2,
      'after',
      {
        overrides: {
          '?': 'before',
          ':': 'before'
        }
      }
    ], //换行时运算符在行尾还是行首
    'padded-blocks': 0, //块语句内行首行尾是否要空行
    quotes: [
      2,
      'single',
      {
        avoidEscape: true,
        allowTemplateLiterals: true
      }
    ], //引号类型 `` &quot;&quot; ''
    semi: [2, 'never'], //语句强制分号结尾
    'semi-spacing': [
      2,
      {
        before: false,
        after: true
      }
    ], //分号前后空格
    'space-before-blocks': [2, 'always'], //不以新行开始的块{前面要不要有空格
    'space-before-function-paren': [2, 'never'], //函数定义时括号前面要不要有空格
    'space-in-parens': [2, 'never'], //小括号里面要不要有空格
    'space-infix-ops': 2, //中缀操作符周围要不要有空格
    'space-unary-ops': [
      2,
      {
        words: true,
        nonwords: false
      }
    ], //一元运算符的前/后要不要加空格
    'spaced-comment': 0, //注释风格不要有空格什么的
    'template-curly-spacing': [2, 'never'],
    'use-isnan': 2, //禁止比较时使用NaN，只能用isNaN()
    'valid-typeof': 2, //必须使用合法的typeof的值
    'wrap-iife': [2, 'any'], //立即执行函数表达式的小括号风格
    'yield-star-spacing': 0,
    yoda: [2, 'never'], //禁止尤达条件
    'prefer-const': 2, //首选const
    'no-debugger': process.env.NODE_ENV === 'production' ? 2 : 0, //禁止使用debugger
    'object-curly-spacing': [
      2,
      'always',
      {
        objectsInObjects: false
      }
    ], //大括号内是否允许不必要的空格
    'array-bracket-spacing': [2, 'never'] //是否允许非空数组里面有多余的空格
  }
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[用van-calendar实现展示指定月份并自定义日期文案]]></title>
        <id>https://liujia12138.github.io/yong-van-calendar-shi-xian-zhan-shi-zhi-ding-yue-fen-bing-zi-ding-yi-ri-qi-wen-an/</id>
        <link href="https://liujia12138.github.io/yong-van-calendar-shi-xian-zhan-shi-zhi-ding-yue-fen-bing-zi-ding-yi-ri-qi-wen-an/">
        </link>
        <updated>2022-04-27T07:19:26.000Z</updated>
        <content type="html"><![CDATA[<p>效果图:<br>
<img src="https://liujia12138.github.io/post-images/1663053616494.jpg" alt="" loading="lazy"></p>
<p>代码：</p>
<pre><code>&lt;template&gt;
  &lt;div&gt;
    &lt;van-button icon=&quot;notes-o&quot; round type=&quot;info&quot; plain size=&quot;mini&quot; @click=&quot;showPicker = true&quot;&gt;
      选择日期&lt;van-icon name=&quot;arrow-down&quot; /&gt;
    &lt;/van-button&gt;

    &lt;van-popup v-model=&quot;showPicker&quot; position=&quot;bottom&quot;&gt;
      &lt;van-datetime-picker
        title=&quot;选择日期&quot;
        type=&quot;year-month&quot;
        v-model=&quot;currentDate&quot;
        :columns-order=&quot;['year', 'month', 'day']&quot;
        @confirm=&quot;onConfirm&quot;
        @cancel=&quot;showPicker = false&quot;
        :formatter=&quot;formatter&quot;
        :max-date=&quot;maxDate&quot;
      /&gt;
    &lt;/van-popup&gt;

    &lt;van-calendar
      v-if=&quot;this.dataList.length &gt; 0&quot;
      :poppable=&quot;false&quot;
      :formatter=&quot;formatterCalendar&quot;
      :default-date=&quot;defaultDate&quot;
      :min-date=&quot;minDate&quot;
      :max-date=&quot;calendarMaxDate&quot;
      :show-title=&quot;false&quot;
      :show-subtitle=&quot;false&quot;
      :show-confirm=&quot;false&quot;
      @select=&quot;selectDate&quot;
    /&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
/**
 * Parse the time to string
 * @param {(Object|string|number)} time
 * @param {string} cFormat
 * @returns {string}
 */
function parseTime(time, cFormat) {
  if (arguments.length === 0) {
    return null
  }
  const format = cFormat || '{y}-{m}-{d} {h}:{i}:{s}'
  let date
  if (typeof time === 'object') {
    date = time
  } else {
    if (typeof time === 'string' &amp;&amp; /^[0-9]+$/.test(time)) {
      time = parseInt(time)
    }
    if (typeof time === 'number' &amp;&amp; time.toString().length === 10) {
      time = time * 1000
    }
    date = new Date(time)
  }
  const formatObj = {
    y: date.getFullYear(),
    m: date.getMonth() + 1,
    d: date.getDate(),
    h: date.getHours(),
    i: date.getMinutes(),
    s: date.getSeconds(),
    a: date.getDay()
  }
  const time_str = format.replace(/{(y|m|d|h|i|s|a)+}/g, (result, key) =&gt; {
    let value = formatObj[key]
    // Note: getDay() returns 0 on Sunday
    if (key === 'a') {
      return ['日', '一', '二', '三', '四', '五', '六'][value]
    }
    if (result.length &gt; 0 &amp;&amp; value &lt; 10) {
      value = '0' + value
    }
    return value || 0
  })
  return time_str
}

export default {
  data() {
    return {
      showPicker: false,
      currentDate: new Date(),
      maxDate: new Date(),
      minDate: new Date(),
      calendarMaxDate: new Date(),
      defaultDate: new Date(),
      dataList: [],
      classList: {}
    }
  },
  computed: {
    formatDate() {
      return parseTime(this.currentDate, this.pickerType === 'date' ? '{y}年{m}月{d}日' : '{y}年{m}月')
    }
  },
  created() {
    this.update()
  },
  methods: {
    formatter(type, val) {
      if (type === 'year') {
        return val + '年'
      }
      if (type === 'month') {
        return val + '月'
      }
      if (type === 'day') {
        return val + '日'
      }
      return val
    },
    onConfirm(value) {
      this.showPicker = false
      this.update(value)
    },
    formatterCalendar(day) {
      const date = day.date.getDate()
      const type = this.dataList[date - 1] || ''

      day.bottomInfo = type
      day.className =
        type === '优'
          ? 'level1'
          : type === '良'
          ? 'level2'
          : type === '轻度'
          ? 'level3'
          : type === '中度'
          ? 'level4'
          : type === '重度'
          ? 'level5'
          : 'level6'
      return day
    },
    update(value) {
      this.dataList = ['优', '良', '中度', '重度', '严重', '优', '优', '良', '中度', '重度', '严重']
      this.defaultDate = value || new Date()
      this.setMinMaxDay()
    },
    // 设置显示月份可选择的天数区间
    setMinMaxDay() {
      const year = new Date(this.defaultDate).getFullYear()
      const month = new Date(this.defaultDate).getMonth()
      const lastDay = new Date(year, month + 1, 0)
      this.minDate = new Date(year, month, 1)
      this.calendarMaxDate = lastDay
    },
    selectDate(date) {
      console.log(date)
    }
  }
}
&lt;/script&gt;
&lt;style&gt;
.van-calendar__month-title {
  display: none;
}
.van-calendar__day {
  font-size: 12px;
  height: 30px;
  line-height: 30px;
  margin-top: 5px;
}
.van-calendar__selected-day {
  background: #cdcbc8;
  color: #515151;
  height: 30px;
  line-height: 30px;
}
.van-calendar__bottom-info {
  border-radius: 5px;
  font-size: 10px;
  padding: 1px 3px;
  color: #fff;
  position: initial;
  vertical-align: middle;
  margin-left: 5px;
}
.level1 .van-calendar__bottom-info {
  background: #b0cb8f;
}
.level2 .van-calendar__bottom-info {
  background: #f2d875;
}
.level3 .van-calendar__bottom-info {
  background: #e5a74c;
}
.level4 .van-calendar__bottom-info {
  background: #cc6065;
}
.level5 .van-calendar__bottom-info {
  background: #ac4176;
}
.level6 .van-calendar__bottom-info {
  background: #7d1f2c;
}
&lt;/style&gt;

</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[怎样实现一个控制台都删不掉的 DOM（保护水印）]]></title>
        <id>https://liujia12138.github.io/zen-yang-shi-xian-yi-ge-kong-zhi-tai-du-shan-bu-diao-de-dombao-hu-shui-yin/</id>
        <link href="https://liujia12138.github.io/zen-yang-shi-xian-yi-ge-kong-zhi-tai-du-shan-bu-diao-de-dombao-hu-shui-yin/">
        </link>
        <updated>2022-04-19T07:17:25.000Z</updated>
        <content type="html"><![CDATA[<h4 id="mutationobserver">MutationObserver</h4>
<p>MutationObserver 提供了监视对 DOM 树所做更改的能力。他被设计为旧的 Mutation Events 功能的替代品，是 DOM3 Event 规范的一部分。<br>
MutationObserver 构造函数会创建并返回一个新的 MutationObserver，在指定的 DOM 发生变化时被调用</p>
<h5 id="方法">方法</h5>
<ol>
<li>
<p>disconnect()<br>
阻止 MutationObserver 实例继续接收的通知，直到再次调用其 observe()方法，该观察者对象包含的回调函数都不会再被调用</p>
</li>
<li>
<p>observe(options)<br>
配置 MutationObserver 在 DOM 更改匹配给定选项时，通过其回调函数开始接收通知。<br>
注意：当调用observe方法时，childList、attributes或者characterData三个属性中，至少有一个必须为true，否则会抛出异常。<br>
options：</p>
<ol>
<li>attributeFilter：要监视的特定属性名称的列表。如果未包含此属性，则对所有属性的更改都会触发变动通知。无默认值。</li>
<li>attributeOldValue：当监视节点的属性改动时，将此属性设置为true，将会记录任何有改动的属性的上一个值。有关观察属性更改和值记录的详细信息。无默认值。</li>
<li>attributes：设置为true时，可以观察受监视元素的属性值的变更。默认为false。</li>
<li>characterData：设置为true时，可以监视指定目标节点或子节点树中节点所包含的字符数据的变化。无默认值</li>
<li>characterDataOldValue：设置为true时，可以在受监视节点上文本数据发生变化时记录节点文本的上一个值。无默认值。</li>
<li>childList：设为true，可以监视目标节点添加或删除子节点的操作。默认值为false。</li>
<li>subtree：设为true，可以将监视范围扩展至目标节点整个节点数树中的所有节点（即子孙节点），MutationObserverInit的其他值也会作用于此子树下的所有节点，而不仅仅只作用于目标节点。默认值为false。</li>
</ol>
</li>
<li>
<p>takeRecords()<br>
从 MutationObserver 的通知队列中删除所有待处理的通知，并将它们返回到 MutationRecord 对象的新 Array 中。</p>
</li>
</ol>
<pre><code class="language-js">const styleStr = `
      position: fixed;
      bottom: 150px;
      left: 200px;
      z-index: 9999;
      transform: rotateZ(-45deg);
      opacity: 0.6;
    `
const nodeId = sjs(10)

createDiv()
parentObserver()

function createDiv() {
  const ele = document.createElement('canvas')
  const ctx = ele.getContext('2d')
  ctx.fillText('MutationObserver', 15, 50)
  ele.setAttribute('id', nodeId)
  ele.setAttribute('style', styleStr)
  document.body.appendChild(ele)
  wmObserver(ele)
}

// wmObserver 监听水印，防止修改水印样式
// 参考：https://juejin.cn/post/7020602166591111205
// 因为水印的样式可以通过控制台修改，如果被设置了 display:none 等样式，也会失去保护作用
// 对于这种情况，我们可以监听水印DOM的style属性，当属性发生变动时，再通过 setAttribute 将正确的样式设置到DOM上
function wmObserver(ele) {
  new MutationObserver(function (mutationsList, observe) {
    const target = mutationsList[0].target
    target.setAttribute('style', styleStr)
    observe.takeRecords()
  }).observe(ele, { attributes: true, childList: true, characterData: true })
}

// parentObserver 监听父级，防止删除水印dom
// 因为被监听的目标节点本身被删除的话是不会触发MutationObserver回调的，所以需要监听水印DOM节点的父元素或者body元素
// 当body作为监听的目标节点时，只有删除掉body时MutationObserver才会失效，此时页面内需要保护的内容也就已经被删掉了，有无水印的意义不大。
function parentObserver() {
  new MutationObserver(function () {
    var e = document.querySelector('#' + nodeId)
    console.log(e)
    // 没有找到水印的dom就生成一个新的
    e ? e.getAttribute('style') !== styleStr &amp;&amp; e.setAttribute('style', styleStr) : createDiv()
  }).observe(document.querySelector('#' + nodeId).parentNode, { childList: true })
}

//随机生成指定长度的字符串
function sjs(leng) {
  // 大写字母、小写字母、数字能出现的情况
  var char = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789'
  // 定义一个字符串接收随机生成的字符串
  var chars = ''
  // 遍历长度
  for (var i = 0; i &lt; leng; i++) {
    // chars 的值为char中下标为随机数的值
    // 这个随机数取值是Math.random()  0-1不到1
    // Math.random()*char.length 0-1之间的数*char的长度，生成一个0-char.length之间的数,取整不包含最后一个，但是length长度为最大下标+1，所以不用加一
    //最后用+来拼接
    chars += char.charAt(parseInt(Math.random() * char.length))
  }
  return chars
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[el-table自定义表头内数据不更新的问题]]></title>
        <id>https://liujia12138.github.io/el-table-zi-ding-yi-biao-tou-nei-shu-ju-bu-geng-xin-de-wen-ti/</id>
        <link href="https://liujia12138.github.io/el-table-zi-ding-yi-biao-tou-nei-shu-ju-bu-geng-xin-de-wen-ti/">
        </link>
        <updated>2021-09-29T06:56:13.000Z</updated>
        <content type="html"><![CDATA[<h3 id="el-table自定义表头使用slotheader数据无法更新">el-table自定义表头，使用slot=&quot;header&quot;数据无法更新</h3>
<p>解决方法：将slot=“header” 改成#header</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[ECharts引入外部字体]]></title>
        <id>https://liujia12138.github.io/echarts-yin-ru-wai-bu-zi-ti/</id>
        <link href="https://liujia12138.github.io/echarts-yin-ru-wai-bu-zi-ti/">
        </link>
        <updated>2021-09-15T06:50:51.000Z</updated>
        <content type="html"><![CDATA[<h3 id="问题描述echarts引入外部字体文件时页面渲染异常出现部分文字没有渲染成指定字体的情况"><strong>问题描述</strong>：echarts引入外部字体文件时，页面渲染异常，出现部分文字没有渲染成指定字体的情况</h3>
<p>如图:<br>
<img src="https://liujia12138.github.io/post-images/1663052022764.png" alt="" loading="lazy"></p>
<h3 id="原因字体文件未加载完成就完成了echarts图表部分的代码">原因：字体文件未加载完成就完成了echarts图表部分的代码</h3>
<h3 id="解决办法等字体下载完再画图或者压缩字体文件">解决办法：等字体下载完再画图或者压缩字体文件</h3>
<pre><code class="language-js">document.fonts.ready.then(()=&gt;{
  //执行echarts图
})
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[uniapp如何在小程序端模拟数据]]></title>
        <id>https://liujia12138.github.io/uniapp-ru-he-zai-xiao-cheng-xu-duan-mo-ni-shu-ju/</id>
        <link href="https://liujia12138.github.io/uniapp-ru-he-zai-xiao-cheng-xu-duan-mo-ni-shu-ju/">
        </link>
        <updated>2021-03-09T06:58:01.000Z</updated>
        <content type="html"><![CDATA[<h3 id="问题描述使用uniapp开发小程序发现运行到微信开发者工具时用mockjs模拟数据接口无法使用">问题描述：使用uniapp开发小程序，发现运行到微信开发者工具时用mockjs模拟数据接口无法使用</h3>
<h3 id="解决办法">解决办法</h3>
<p>使用better-mock</p>
<h4 id="安装better-mock">安装better-mock</h4>
<p>[官方文档]&lt;!https://lavyun.github.io/better-mock/document/&gt;</p>
<pre><code>cnpm install better-mock --save-D
</code></pre>
<h4 id="引入better-mock">引入better-mock</h4>
<p>因为better-mock完全兼容mockjs，只需要将mock目录下index.js中</p>
<pre><code>const Mock = require('mockjs')
</code></pre>
<p>改为</p>
<pre><code>const Mock = require('better-mock/dist/mock.mp.js')
</code></pre>
<p>再次运行就可以在微信开发者工具看到模拟的数据啦</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[vue报错You are using the runtime-only build of Vue where the template compiler is not available]]></title>
        <id>https://liujia12138.github.io/vue-bao-cuo-you-are-using-the-runtime-only-build-of-vue-where-the-template-compiler-is-not-available/</id>
        <link href="https://liujia12138.github.io/vue-bao-cuo-you-are-using-the-runtime-only-build-of-vue-where-the-template-compiler-is-not-available/">
        </link>
        <updated>2021-03-02T06:59:17.000Z</updated>
        <content type="html"><![CDATA[<h3 id="问题描述使用vueant-design-vue时因为menu组件在v20之前不支持单文件递归所以使用了函数式组件但是编译时出现了下面的报错">问题描述：使用vue+ant-design-vue时，因为Menu组件在V2.0之前不支持单文件递归，所以使用了函数式组件，但是编译时出现了下面的报错</h3>
<pre><code>[Vue warn]: You are using the runtime-only build of Vue where the template compiler is not available. Either pre-compile the templates into render functions, or use the compiler-included build.
</code></pre>
<p>翻译：您正在使用仅在运行时构建的Vue，其中模板编译器不可用。要么将模板预编译为呈现函数，要么使用包含编译器的构建。</p>
<h4 id="原因">原因：</h4>
<p>vue的构建版本分为：UMD， CommonJS，ES Module<br>
<a href="https://cn.vuejs.org/v2/guide/installation.html">https://cn.vuejs.org/v2/guide/installation.html</a></p>
<p><img src="https://liujia12138.github.io/post-images/1663052383565.png" alt="构建版本" loading="lazy"><br>
<img src="https://liujia12138.github.io/post-images/1663052405859.png" alt="术语" loading="lazy"></p>
<p>vue默认的是运行时的版本，无法处理模板字符串的编译工作，需要使用包含编译器的构建</p>
<p>当需要客户端编译模板，如向template中传入一个字符串，或者需要将模板中的非DOM挂载到一个元素上时，就需要带有编译器（compiler）的构建版本。</p>
<p>而.vue文件中的模板会在构建时预编译（pre-compile）为JavaScript，最终生成的bundle中不再需要编译器，因此通常情况下只需要包含运行时（runtime-only）的构建版本</p>
<h4 id="解决方法">解决方法</h4>
<p>在项目目录下新建vue.config.js，添加配置，使用包含运行时编译器的构建版本</p>
<pre><code class="language-js">module.exports = {
  //Solution For Issue:You are using the runtime-only build of Vue where the template compiler is not available. Either pre-compile the templates into render functions, or use the compiler-included build.
  runtimeCompiler: true
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[css实现文字渐变色]]></title>
        <id>https://liujia12138.github.io/css-shi-xian-wen-zi-jian-bian-se/</id>
        <link href="https://liujia12138.github.io/css-shi-xian-wen-zi-jian-bian-se/">
        </link>
        <updated>2021-02-25T06:47:57.000Z</updated>
        <content type="html"><![CDATA[<h4 id="实现文字颜色渐变有两种方法">实现文字颜色渐变有两种方法</h4>
<ol>
<li>使用 background-clip 属性</li>
</ol>
<pre><code class="language-css">.text {
  background: linear-gradient(90deg, #326be6 0%, #0fcae2 100%);
  -webkit-background-clip: text;
  color: transparent;
}
</code></pre>
<h5 id="扩展">扩展</h5>
<ul>
<li>background-clip,背景裁剪,作用就是设置背景的填充规则<br>
和 box-sizing 的取值非常类似，有三个值</li>
</ul>
<pre><code class="language-css"> {
  background-clip: border-box; /*背景延伸到边框外延，但是再边框之下*/
  background-clip: content-box; /*背景剪裁到内容区外沿*/
  background-clip: padding-box; /*背景延伸到内边距外沿*/
}
</code></pre>
<ul>
<li>background-clip: text; 只有 chrome 支持，需要写成 -webkit-background-clip:text<br>
以区块内的文字作为裁剪区域向外剪裁。文字的背景即为区块的背景，通常需要配合文字颜色设置为 transparent</li>
</ul>
<p>示例：</p>
<pre><code class="language-css">.text {
  color: transparent;
  border: 5px solid transparent;
  background: linear-gradient(120deg, #333 0%, #265fae 30%, red 60%, pink 100%);
  background-clip: content-box;
  -webkit-background-clip: text;
  font-size: 60px;
}
</code></pre>
<p>效果图:<br>
<img src="https://liujia12138.github.io/post-images/1663051783274.png" alt="" loading="lazy"></p>
<ol>
<li>使用 mask-image 属性</li>
</ol>
<p>示例</p>
<pre><code class="language-css">.text {
  color: red;
  font-size: 60px;
  position: relative;
}
.text[data-content]::after {
  content: attr(data-content);
  display: block;
  color: yellow;
  z-index: 2;
  position: absolute;
  top: 0;
  left: 0;
  -webkit-mask-image: linear-gradient(180deg, yellow 0%, transparent 100%);
  mask-image: linear-gradient(180deg, yellow 0%, transparent 100%);
}
</code></pre>
<pre><code class="language-html">&lt;div class=&quot;text&quot; data-content=&quot;content&quot;&gt;content&lt;/div&gt;
</code></pre>
<figure data-type="image" tabindex="1"><img src="https://liujia12138.github.io/post-images/1663051769813.png" alt="" loading="lazy"></figure>
<p>其实就是将一个黄色到透明渐变的文字覆盖到本身红色的字上面，mask-image兼容性要高于第一种方法</p>
]]></content>
    </entry>
</feed>