<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://liujia12138.github.io</id>
    <title>AzhA</title>
    <updated>2020-05-08T14:58:14.572Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://liujia12138.github.io"/>
    <link rel="self" href="https://liujia12138.github.io/atom.xml"/>
    <subtitle>温故而知新</subtitle>
    <logo>https://liujia12138.github.io/images/avatar.png</logo>
    <icon>https://liujia12138.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, AzhA</rights>
    <entry>
        <title type="html"><![CDATA[js总结]]></title>
        <id>https://liujia12138.github.io/post/js-mian-shi-ti-zong-jie/</id>
        <link href="https://liujia12138.github.io/post/js-mian-shi-ti-zong-jie/">
        </link>
        <updated>2020-05-06T12:40:35.000Z</updated>
        <content type="html"><![CDATA[<p>1.事件冒泡和事件捕获<br>
事件捕获：事件从最不确定的元素向最准确的元素开始触发，即由外向内<br>
事件冒泡：事件从最准确的元素开始向最不准确的元素触发，即由内向外</p>
<p>addEventListener()有三个参数，第一个参数是绑定的事件类型；第二个是触发事件时执行的函数；第三个是 是否在捕获阶段触发事件，默认是false。</p>
<p>怎么阻止事件冒泡？event.stopPropagation()，vue项目中用stop修饰符</p>
<p>为什么要阻止事件冒泡？<br>
我们再多数情况下只使用冒泡监听。在一个列表页中，每一条信息中右下角会有一个删除按钮，同时点击这一条消息又会进入到详情页。当我们点击了删除按钮事件执行完毕之后，由于事件冒泡，会触发外层进入详情页的事件，这时就需要给删除按钮一个阻止事件传递的功能，点击删除按钮之后事件就会结束。</p>
<p>2.js获取url中的参数<br>
function getQueryString(name) {<br>
var reg = new RegExp(&quot;(^|&amp;)&quot; + name + &quot;=([^&amp;]*)(&amp;|$)&quot;, &quot;i&quot;);<br>
var r = window.location.search.substr(1).match(reg);<br>
if (r != null) return decodeURI(r[2]);<br>
return &quot;&quot;;<br>
}<br>
3.post请求能否跨域？<br>
post跨域问题本身是因为请求的域名和用于请求的机器域名不一致造成的，例如本地是127.0.0.1域名，请求的是192.168.50.11，在Network里面可以看到会接受到返回值，但是控制台会报请求头不一致的跨域问题，是因为浏览器对后台返给我结果进行了检测，发现两个环境域名不一致，所以解决的办法就是后台在接受到请求的时候，在返回头信息里面加入指定域名可访问或者所有域名都可以访问就可以，这样后台接收到请求之后的返回头里面就指定了对比的请求头，所以前端就能收到返回值了。</p>
<p>Access-Control-Allow-Headers: DNT,X-Mx-ReqToken,Keep-Alive,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type,Authorization,userid,sign<br>
Access-Control-Allow-Methods: GET, POST, OPTIONS<br>
Access-Control-Allow-Origin: *<br>
//加上过滤方法之后的返回头信息，*代表允许所有的域名访问<br>
4.页面性能优化<br>
减少http请求，减少http请求次数是缩短响应时间的关键，捆绑文件，将多个脚本文件捆绑成一个，以此来减少http请求次数<br>
使用css精灵图<br>
减少事件绑定，使用事件委托<br>
引用外部的css和js，而不是写在html文件内，有利于浏览器对文件进行缓存<br>
合理设置 HTTP缓存　　缓存的力量是强大的，恰当的缓存设置可以大大的减少 HTTP请求。以有啊首页为例，当浏览器没有缓存的时候访问一共会发出 78个请求，共 600多 K数据 (如图 1.1)，而当第二次访问即浏览器已缓存之后访问则仅有 10个请求，共 20多 K数据 (如图 1.2)。 (这里需要说明的是，如果直接 F5刷新页面的话效果是不一样的，这种情况下请求数还是一样，不过被缓存资源的请求服务器是 304响应，只有 Header没有Body ，可以节省带宽 )　　怎样才算合理设置 ?原则很简单，能缓存越多越好，能缓存越久越好。例如，很少变化的图片资源可以直接通过 HTTP Header中的Expires设置一个很长的过期头 ;变化不频繁而又可能会变的资源可以使用 Last-Modifed来做请求验证。尽可能的让资源能够在缓存中待得更久。<br>
减少dom操作<br>
5.原生ajax<br>
var xhr = new XMLHttpRequest();<br>
xhr.onreadystatechange= function(){<br>
if(xhr.readyState == 4 &amp;&amp; xhr.status == 200){<br>
console.log(xhr.responseText)<br>
}<br>
}<br>
//发送get请求时，参数直接拼接在url上<br>
xhr.open(&quot;get&quot;, &quot;url?param1=val1&amp;param2=val2&quot;);<br>
//发送post请求时，参数用send函数发送，并且需要设置请求头<br>
xhr.open(&quot;post&quot;, &quot;url&quot;);<br>
xhr.setRequestHeader('Content-Type', &quot;application/x-www-form-urlencoded&quot;)<br>
xhr.send(&quot;name=value&amp;age=12&quot;)<br>
6.js判断数据类型的方法<br>
typeof 只能对基本数据类型做出准确的判断，引用数据类型都会返回object，typeof的返回结果有：number、string、undefined、boolean、object、function六种，都是小写<br>
instanceof：判断对象和构造函数在原型链上是否有关联，有返回true，无返回false，基本数据类型无效<br>
constructor：查看对象对应的构造函数，当我们写一个构造函数的时候程序会自动添加；构造函数名.prototype.constructor=构造函数名；<br>
str.constructor == String;//true<br>
object.prototype.toString.call: 不管是什么类型都能检测出来<br>
7. call和apply,bind的区别？<br>
call、apply、bind的作用是改变函数运行时this的指向</p>
<p>2.js垃圾回收与内存泄漏？<br>
浏览器的JavaScript具有自动垃圾回收机制（GC），即执行环境会负责管理代码执行过程中的内存。原理是：垃圾收集器会定期找出那些不在继续使用的变量，然后将其内存进行释放。</p>
<p>垃圾回收机制标记无用变量的策略有两种：标记清除和引用计数。标记清除较为常用。</p>
<p>不在使用的变量就是生命周期结束的变量，只能是局部变量，因为全局变量的生命周期直到浏览器卸载页面是才会结束。局部变量只在函数的执行过程中存在，在这个过程中会在栈或者堆上为这个局部变量分配相应的空间用来存储他们的值，直到函数结束。但是闭包中由于你不函数的原因，外部函数不能算是结束。</p>
<p>function fn1(){<br>
var obj = {name: &quot;tom&quot;}<br>
}<br>
function fn2(){<br>
var obj = {name:&quot;tom&quot;};<br>
return obj;<br>
}<br>
var a = fn1();<br>
var b = fn2();<br>
上面的例子中，只有fn1中的obj会在调用结束后被垃圾回收机制回收，fn2中的obj不会，因为在fn2的调用过程中，返回的变量被变量b引用，所以不会改块内存不会被释放。</p>
<p>1.标记清除：当变量进入环境时，就将这个变量标记为“进入环境”，当变量离开环境时，将它标记为“离开环境”</p>
<p>function test(){<br>
var a = 10 ;       // 被标记 ，进入环境<br>
var b = 20 ;       // 被标记 ，进入环境<br>
}<br>
test();            // 执行完毕 之后 a、b又被标离开环境，被回收。<br>
2.引用计数：跟踪每个值被引用的次数，引用一次就将次数加1，如果包含这个值的变量又被赋了另外一个值，引用次数就减1，当引用次数为0时，垃圾回收机制就会释放该值所占用的内存。</p>
<p>function test() {<br>
var a = {};    // a指向对象的引用次数为1<br>
var b = a;     // a指向对象的引用次数加1，为2<br>
var c = a;     // a指向对象的引用次数再加1，为3<br>
var b = {};    // a指向对象的引用次数减1，为2<br>
}</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[css实现宽高比]]></title>
        <id>https://liujia12138.github.io/post/css-shi-xian-kuan-gao-bi/</id>
        <link href="https://liujia12138.github.io/post/css-shi-xian-kuan-gao-bi/">
        </link>
        <updated>2020-05-06T12:37:43.000Z</updated>
        <content type="html"><![CDATA[<p>垂直方向的padding+calc<br>
借助padding-top或者padding-bottom的百分比值来实现容器的宽高比，padding的百分比值是根据外层容器的宽度计算的，我们只需要设置好外层容器的宽度，并将容器的高度设置为0，容器所有子元素都设置绝对定位。</p>
<!-- html如下 -->
<div class='container'>
    <div class='aspectration' data-ratio='4:3'>
        <div class='content'></div>
    </div>
</div>
.container{
    width: 300px;
}
.aspectration{
    width: 100%;
    position: relative;
    height: 0;
}
.aspectration[data-ratio='4:3']{
    padding-top: calc(100% / 4 * 3);
}
.aspectration>*{
    position: absolute;
    width: 100%;
    height: 100%;
    left: 0;
    top: 0;
}]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[vue项目安装sass-loader]]></title>
        <id>https://liujia12138.github.io/post/vue-xiang-mu-an-zhuang-sass-loader/</id>
        <link href="https://liujia12138.github.io/post/vue-xiang-mu-an-zhuang-sass-loader/">
        </link>
        <updated>2020-05-06T12:36:12.000Z</updated>
        <content type="html"><![CDATA[<p>安装sass依赖包<br>
npm install sass-loader --save-dev<br>
安装node-sass，因为sass-loader依赖于node-sass<br>
npm install node-sass --save-dev<br>
在build文件夹下的webpack.base.conf.js的rules里面添加配置<br>
{<br>
test: &quot;sass&quot;,<br>
loader: ['style', 'css', 'sass']<br>
}</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[JS宏任务微任务和事件循环]]></title>
        <id>https://liujia12138.github.io/post/js-hong-ren-wu-wei-ren-wu-he-shi-jian-xun-huan/</id>
        <link href="https://liujia12138.github.io/post/js-hong-ren-wu-wei-ren-wu-he-shi-jian-xun-huan/">
        </link>
        <updated>2020-01-07T13:13:21.000Z</updated>
        <content type="html"><![CDATA[<p>js是一门单线程语言，所有任务都需要排队执行，如果上一个任务要消耗很长的时间，下一个任务都不得不等待很长时间，这时设计者就把任务分为了同步任务和异步任务。同步任务在主线程上一个个执行，异步任务则会加入到任务队列，只有所有同步任务执行完，才会执行异步任务。</p>
<p>异步任务有：setTimeout，setInterval，dom事件，promise， ajax</p>
<p>按照这样的话，上面例子的setTimeout和promise是异步任务，加入到任务队列然后依次执行，但并不是这样，任务又分为宏任务和微任务</p>
<p>宏任务和微任务：宏任务优先于微任务执行， 宏任务包括整体代码script，setTimeout，setInterval； 微任务包括promise，process.nextTick</p>
<p>所以上面的例子先打印start---然后遇到setTimeout，setTimeout属于异步任务也属于宏任务，放到task（宏任务队列）里面---然后是promise，也是异步任务，但是是微任务，所以放到microtask（微任务队列）里面---然后执行到最后打印end；此时主线程js stack被清空。</p>
<p>主线程执行完毕之后就会去清空微任务，所以接下来promise.then会被加入到主线程中去执行，执行完毕后，主线程又被清空了</p>
<p>此时微任务队列里还有刚刚产生的promise.then，又被加入到主线程，打印出promise2</p>
<p>此时微任务和主线程都被清空，接着从宏任务队列中取出一个宏任务加入到主线程中执行，打印出setTimeout</p>
<p>此时主线程，微任务队列，宏任务队列都被清空了。</p>
<p>如果宏任务队列和微任务队列还没清空，就会：主栈全部执行完毕后--&gt;清空微任务--&gt;会取出一个宏任务 --&gt; 执行完毕后--&gt;清空微任务 -&gt; 无线循环，这就是我们所说的事件环（Event Loop），也就是javascript的执行机制。</p>
<p>看下面的例子</p>
<pre><code>&lt;div class=&quot;outer&quot;&gt;
  &lt;div class=&quot;inner&quot;&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;script&gt;
// Let's get hold of those elements
var outer = document.querySelector('.outer');
var inner = document.querySelector('.inner');

// Let's listen for attribute changes on the
// outer element
//监听element属性变化
new MutationObserver(function() {
  console.log('mutate');
}).observe(outer, {
  attributes: true
});

// Here's a click listener…
function onClick() {
  console.log('click');

  setTimeout(function() {
    console.log('timeout');
  }, 0);

  Promise.resolve().then(function() {
    console.log('promise');
  });

  outer.setAttribute('data-random', Math.random());
}

// …which we'll attach to both elements
inner.addEventListener('click', onClick);
outer.addEventListener('click', onClick);
&lt;/script&gt;
</code></pre>
<p>点击inner会打印什么？</p>
<p>click事件是宏任务，加入到宏任务队列，setTimeout也是宏任务，promise和MutationObserver是微任务，加入到微任务队列 click promise mutate click promise mutate timeout timeout</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[浏览器输入一个url到页面渲染出来都发生了什么？]]></title>
        <id>https://liujia12138.github.io/post/liu-lan-qi-shu-ru-yi-ge-url-dao-ye-mian-xuan-ran-chu-lai-du-fa-sheng-liao-shi-me/</id>
        <link href="https://liujia12138.github.io/post/liu-lan-qi-shu-ru-yi-ge-url-dao-ye-mian-xuan-ran-chu-lai-du-fa-sheng-liao-shi-me/">
        </link>
        <updated>2019-05-07T13:23:32.000Z</updated>
        <content type="html"><![CDATA[<p>主要分为三个过程：DNS解析，浏览器发起请求和服务器交互，浏览器接收到对应的html进行页面渲染</p>
<h3 id="1dns解析">1.DNS解析：</h3>
<p>浏览器向dns服务器发送域名，dns服务器查询到对应的ip地址返回给浏览器，浏览器获取到ip地址和参数一起发送给对应的服务器，发起http请求</p>
<h3 id="2浏览器发送请求与服务器交互">2.浏览器发送请求与服务器交互</h3>
<ul>
<li>1.浏览器通过三次握手与服务器建立连接</li>
<li>2.浏览器根据解析得到的ip地址和端口号发起http get请求</li>
<li>3.服务器接收到get请求，查找对应的html文件，使用http返回响应报文</li>
<li>4.如果状态码是200，响应成功，浏览及接收到对应的页面，开始渲染</li>
</ul>
<h3 id="3浏览器渲染页面">3.浏览器渲染页面</h3>
<ul>
<li>1.解析html生成dom树</li>
<li>2.解析css，构建cssom树</li>
<li>3.加载js</li>
<li>4.dom树和cssom树结合构成渲染（render）树</li>
<li>
<ol start="5">
<li></li>
</ol>
</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[节流和防抖]]></title>
        <id>https://liujia12138.github.io/post/jie-liu-he-fang-dou/</id>
        <link href="https://liujia12138.github.io/post/jie-liu-he-fang-dou/">
        </link>
        <updated>2019-03-14T13:59:36.000Z</updated>
        <content type="html"><![CDATA[<p>一些用户频繁触发的事件操作，对于dom操作，资源加载等消耗性能的处理可能会导致页面卡顿，这时就需要用到函数节流（throttle）和函数防抖（debounce）</p>
<h4 id="函数防抖">函数防抖</h4>
<p>事件被触发n秒之后再执行，如果在这个n秒之内被再次触发，就重新计时</p>
<p>使用场景：</p>
<ul>
<li>做输入框自动补全提示（实时搜索），需要监听用户的输入行为，根据输入内容去请求后端接口，如果不做函数防抖的话，每次触发keyup就要请求一次，非常消耗性能</li>
<li>拖拽</li>
</ul>
<p>实现函数防抖：用setTimeout</p>
<pre><code class="language-js">function debounce(fn, delay){
    var timer;
    return function(e){
        var that =  this;
        clearTimeout(timer);
        timer = setTimeout(function(){
            fn.call(that, e)
        }, delay)
    }
}

function fn(args){
    console.log(args)
}
document.getElementById('debounce').addEventListener(&quot;click&quot;,function(e){
    debounce(click, 500)(e)
})
</code></pre>
<h4 id="函数节流">函数节流</h4>
<p>预定一个函数只有在大于等于执行周期时才执行，周期内调用不执行，不管函数触发的多频繁都会保证一个周期执行一次</p>
<p>使用场景：</p>
<ul>
<li>窗口resize</li>
<li>页面滚动scroll</li>
</ul>
<p>实现函数节流：</p>
<pre><code class="language-js">function throttle(fn, delay){
    let prev = 0;
    return function(args){
        let that = this;
        let now = Date.now();
        if(now - prev &gt;= delay){
            fn.call(that, args);
            prev = now;
        }
    }
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[vuex的辅助函数和基本属性使用的区别?]]></title>
        <id>https://liujia12138.github.io/post/vuex-de-fu-zhu-han-shu-he-ji-ben-shu-xing-shi-yong-de-qu-bie/</id>
        <link href="https://liujia12138.github.io/post/vuex-de-fu-zhu-han-shu-he-ji-ben-shu-xing-shi-yong-de-qu-bie/">
        </link>
        <updated>2018-10-17T14:54:05.000Z</updated>
        <content type="html"><![CDATA[<h5 id="1-state">1. state</h5>
<p>当我们需要读取state中的一个属性的时候，可以在组件内用computed来读取，这样当state变化的时候，组件就能实时改变<br>
但是如果组件内需要用到多个state，每个状态都声明为计算属性的话重复代码就太多了，这是就需要用到辅助函数mapState来帮助我们生成计算属性</p>
<pre><code class="language-js">computed:{
    count(){
        //....
    },
    ...mapState({//结合展开运算符使用
        &quot;count&quot;,//等同于  this.count ：store.state.count
        count: state =&gt; state.count
    })
}
</code></pre>
<h5 id="2-getter">2. getter</h5>
<p>当我们需要从store的state中派生出一些状态，比如一个list的长度，过滤掉某个state中的一些数据，可以在getter中定义这个派生状态</p>
<p>可以理解为getter就是state的计算属性，在组件中使用store.getters.count访问</p>
<p>getter和计算属性一样，返回值会根据他的依赖被缓存起来，只有当他的依赖值发生变化时才会重新计算<br>
<strong>（computed和watch的区别？）</strong></p>
<p>可以通过让getter返回一个函数来实现给getter传参</p>
<p>mapGetters辅助函数：将store中的getter映射到组件的计算属性中</p>
<h5 id="3-mutation">3. mutation</h5>
<p>更改vuex中store中的状态的唯一方法就是提交mutation。</p>
<p>mutation类似事件，每个mutation都有一个字符串的事件类型type（函数名）和一个回调函数，这个回调函数就是我们实际进行状态更改的地方，他会接受state作为第一个参数。</p>
<pre><code class="language-js">const mutations = {
    increment(state){
        state.count++
    }
}
</code></pre>
<p>但是我们修改state的时候，不能够直接调用mutation的回调函数increment()，需要使用store.commit(type)来调用相应的方法</p>
<p>我们也可以向store.commit中传入额外的参数，传递给mutation，即mutation的载荷 <code>store.commit('increment', 10)</code></p>
<pre><code class="language-js">const mutations = {
    increment(state, n){
        state.count += n
    }
}
</code></pre>
<p>使用常量代替mutation事件类型，在各种Flux中非常常见，可以把这些常量单独放在一个文件中，这样整个app包含的mutation看起来非常清晰</p>
<pre><code class="language-js">//mutation-types.js
export const SOME_MUTATION = &quot;SOME_MUTATION&quot;
</code></pre>
<pre><code class="language-js">import Vuex from 'vuex'
import {SOME_MUTATION} from &quot;mutation-types.js&quot;

const store = new Vuex.store({
    state: {...},
    mutations: {
        //可以使用常量来作为函数名
        [SOME_MUTATION](state){
            //....
        }
    }
})
</code></pre>
<p><strong>mutation必须是同步函数</strong></p>
<p>在组件中提交mutation，可以使用<code>this.$store.commit('xxx', payload)</code>来提交mutation，或者使用mapMutations辅助函数将组件中的methods映射为store.commit来调用</p>
<h5 id="4action">4.action</h5>
<p>action类似于mutation，但是不同的是action修改状态是通过提交mutation，而不是直接修改状态；<strong>action可以进行异步操作</strong></p>
<pre><code class="language-js">const store = new Vuex.Store({
  state: {
    count: 0
  },
  mutations: {
    increment (state) {
      state.count++
    }
  },
  actions: {
    increment (context) {
      context.commit('increment')
    }
  }
})
</code></pre>
<p>从上面例子我们可以看出，action函数接收一个和store实例具有相同方法和属性的context对象，因此我们可以调用context.commit()来提交mutation，或者通过context.getters和context.state来获取getters和state。</p>
<p><strong>注意</strong>：context对象并不是store实例本身。</p>
<p>分发action，可以通过<code>store.dispatch('increment')</code>来触发<br>
在组件中分发action，可以使用 <code>this.$store.dispatch('increment')</code>,或者使用mapActions将组件的methods映射为store.dispatch调用（需要在根节点注入store）</p>
<p>组合action：actions通常是异步的，怎么才能知道action什么时候结束呢？</p>
<ul>
<li>可以在action内返回promise，组件内使用<code>this.$store.dispatch('increment').then(()=&gt;{})</code></li>
<li>利用async/await</li>
</ul>
<pre><code class="language-js">actions: {
    async actionA({commit}){
        commit('gotData', await getData());//getData返回的是promise
    }
}
</code></pre>
<h5 id="5module">5.<a href="https://vuex.vuejs.org/zh/guide/modules.html">module</a></h5>
<p>为了方便模块化开发，vuex允许我们将store分割成module，每个模块拥有自己的state，getter，mutation，action；</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[CSS预处理器，sass、less、stylus]]></title>
        <id>https://liujia12138.github.io/post/css-yu-chu-li-qi-sasslessstylus/</id>
        <link href="https://liujia12138.github.io/post/css-yu-chu-li-qi-sasslessstylus/">
        </link>
        <updated>2018-07-10T12:38:58.000Z</updated>
        <content type="html"><![CDATA[<p>css预处理器是一种专门用来为css增加编程特性的编程语言，css本身不是编程语言。</p>
<p>css预处理器的作用：</p>
<p>css语法不够强大，选择器无法嵌套，导致css中存在较多重复的选择器语句；<br>
css无法定义变量，没有合理的样式复用机制，css预处理器为css提供样式复用机制，减少css代码冗余，提高css可维护性；<br>
工作流程（以sass为例）：</p>
<p>以sass提供的语法规则编写样式；<br>
编译器把sass代码转换成标准的css代码；<br>
浏览器加载解析后的css样式；<br>
主流css预处理器：</p>
<p>sass：最早最成熟的css预处理器，有两种语法，分别以.sass和.scss为扩展名，scss兼容css3<br>
less<br>
stylus：主要用来给node项目进行css预处理，以.styl为扩展名</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[为什么页面写了setTimeout要在页面销毁时清除这个timeout？]]></title>
        <id>https://liujia12138.github.io/post/wei-shi-me-ye-mian-xie-liao-settimeout-yao-zai-ye-mian-xiao-hui-shi-qing-chu-zhe-ge-timeout/</id>
        <link href="https://liujia12138.github.io/post/wei-shi-me-ye-mian-xie-liao-settimeout-yao-zai-ye-mian-xiao-hui-shi-qing-chu-zhe-ge-timeout/">
        </link>
        <updated>2018-07-06T12:38:05.000Z</updated>
        <content type="html"><![CDATA[<p>vue、react等创建的单页面应用，切换路由的时候并不会刷新页面，定时器也不会被销毁，所以需要在beforeDestroy中手动清除；</p>
<p>用setTimeout实现setInterval？</p>
<pre><code>var t = null;
var count = 0;
function time(){
    clearTimeout(t);
    count ++;
    t = setTimeout(time, 1000);
}
t = setTimeout(time, 1000);
var t = null;
function f(fn, time){
    var _this = this;
    var args = [...arguments].slice(2)
    function setFun(){
        clearTimeout(t);
        t = setTimeout(function(){
            setFun();
            fn(args);
        }, time)
    }
    setFun();
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[圣杯布局和双飞翼布局]]></title>
        <id>https://liujia12138.github.io/post/sheng-bei-bu-ju-he-shuang-fei-yi-bu-ju/</id>
        <link href="https://liujia12138.github.io/post/sheng-bei-bu-ju-he-shuang-fei-yi-bu-ju/">
        </link>
        <updated>2018-06-07T13:51:30.000Z</updated>
        <content type="html"><![CDATA[<p>参考：<a href="https://www.jianshu.com/p/81ef7e7094e8">圣杯布局和双飞翼布局</a></p>
<p>都是三栏布局，左右两边宽度固定，中间宽度自适应</p>
<ul>
<li>圣杯布局：左浮动+定位</li>
</ul>
<p>主体部分container内包括center，left、right三个子元素，让这个三个子元素都float：left；container设置padding左右的值为左右元素的 width；然后给左右两侧的元素设置宽度，然后左边的元素margin-left：-100%;position:relative;right:(left的宽度)，右边的元素margin-right：-（width）；</p>
<p>注意中间元素一定要设置宽度为100%，因为设置了浮动，是行内块，内容太少的话宽度会自己缩到内容的大小</p>
<ul>
<li>双飞翼布局：只用了float，没有定位</li>
</ul>
<p>与圣杯布局的区别是container只包裹住center</p>
<p>conatiner和left、right平级，全都左浮动，container宽度为100%来保证宽度自适应，left和right设置宽度，center设置margin-left和margin-right分别为左右元素的宽度，left设置margin-left：-100%，right设置margin-left：-（right的宽度）;<br>
给外层容器清浮动</p>
]]></content>
    </entry>
</feed>