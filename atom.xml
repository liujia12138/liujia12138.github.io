<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://liujia12138.github.io</id>
    <title>AzhA</title>
    <updated>2020-05-06T12:48:44.930Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://liujia12138.github.io"/>
    <link rel="self" href="https://liujia12138.github.io/atom.xml"/>
    <subtitle>温故而知新</subtitle>
    <logo>https://liujia12138.github.io/images/avatar.png</logo>
    <icon>https://liujia12138.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, AzhA</rights>
    <entry>
        <title type="html"><![CDATA[js面试题总结]]></title>
        <id>https://liujia12138.github.io/post/js-mian-shi-ti-zong-jie/</id>
        <link href="https://liujia12138.github.io/post/js-mian-shi-ti-zong-jie/">
        </link>
        <updated>2020-05-06T12:40:35.000Z</updated>
        <content type="html"><![CDATA[<p>1.事件冒泡和事件捕获<br>
事件捕获：事件从最不确定的元素向最准确的元素开始触发，即由外向内<br>
事件冒泡：事件从最准确的元素开始向最不准确的元素触发，即由内向外</p>
<p>addEventListener()有三个参数，第一个参数是绑定的事件类型；第二个是触发事件时执行的函数；第三个是 是否在捕获阶段触发事件，默认是false。</p>
<p>怎么阻止事件冒泡？event.stopPropagation()，vue项目中用stop修饰符</p>
<p>为什么要阻止事件冒泡？<br>
我们再多数情况下只使用冒泡监听。在一个列表页中，每一条信息中右下角会有一个删除按钮，同时点击这一条消息又会进入到详情页。当我们点击了删除按钮事件执行完毕之后，由于事件冒泡，会触发外层进入详情页的事件，这时就需要给删除按钮一个阻止事件传递的功能，点击删除按钮之后事件就会结束。</p>
<p>2.js获取url中的参数<br>
function getQueryString(name) {<br>
var reg = new RegExp(&quot;(^|&amp;)&quot; + name + &quot;=([^&amp;]*)(&amp;|$)&quot;, &quot;i&quot;);<br>
var r = window.location.search.substr(1).match(reg);<br>
if (r != null) return decodeURI(r[2]);<br>
return &quot;&quot;;<br>
}<br>
3.post请求能否跨域？<br>
post跨域问题本身是因为请求的域名和用于请求的机器域名不一致造成的，例如本地是127.0.0.1域名，请求的是192.168.50.11，在Network里面可以看到会接受到返回值，但是控制台会报请求头不一致的跨域问题，是因为浏览器对后台返给我结果进行了检测，发现两个环境域名不一致，所以解决的办法就是后台在接受到请求的时候，在返回头信息里面加入指定域名可访问或者所有域名都可以访问就可以，这样后台接收到请求之后的返回头里面就指定了对比的请求头，所以前端就能收到返回值了。</p>
<p>Access-Control-Allow-Headers: DNT,X-Mx-ReqToken,Keep-Alive,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type,Authorization,userid,sign<br>
Access-Control-Allow-Methods: GET, POST, OPTIONS<br>
Access-Control-Allow-Origin: *<br>
//加上过滤方法之后的返回头信息，*代表允许所有的域名访问<br>
4.页面性能优化<br>
减少http请求，减少http请求次数是缩短响应时间的关键，捆绑文件，将多个脚本文件捆绑成一个，以此来减少http请求次数<br>
使用css精灵图<br>
减少事件绑定，使用事件委托<br>
引用外部的css和js，而不是写在html文件内，有利于浏览器对文件进行缓存<br>
合理设置 HTTP缓存　　缓存的力量是强大的，恰当的缓存设置可以大大的减少 HTTP请求。以有啊首页为例，当浏览器没有缓存的时候访问一共会发出 78个请求，共 600多 K数据 (如图 1.1)，而当第二次访问即浏览器已缓存之后访问则仅有 10个请求，共 20多 K数据 (如图 1.2)。 (这里需要说明的是，如果直接 F5刷新页面的话效果是不一样的，这种情况下请求数还是一样，不过被缓存资源的请求服务器是 304响应，只有 Header没有Body ，可以节省带宽 )　　怎样才算合理设置 ?原则很简单，能缓存越多越好，能缓存越久越好。例如，很少变化的图片资源可以直接通过 HTTP Header中的Expires设置一个很长的过期头 ;变化不频繁而又可能会变的资源可以使用 Last-Modifed来做请求验证。尽可能的让资源能够在缓存中待得更久。<br>
减少dom操作<br>
5.原生ajax<br>
var xhr = new XMLHttpRequest();<br>
xhr.onreadystatechange= function(){<br>
if(xhr.readyState == 4 &amp;&amp; xhr.status == 200){<br>
console.log(xhr.responseText)<br>
}<br>
}<br>
//发送get请求时，参数直接拼接在url上<br>
xhr.open(&quot;get&quot;, &quot;url?param1=val1&amp;param2=val2&quot;);<br>
//发送post请求时，参数用send函数发送，并且需要设置请求头<br>
xhr.open(&quot;post&quot;, &quot;url&quot;);<br>
xhr.setRequestHeader('Content-Type', &quot;application/x-www-form-urlencoded&quot;)<br>
xhr.send(&quot;name=value&amp;age=12&quot;)<br>
6.js判断数据类型的方法<br>
typeof 只能对基本数据类型做出准确的判断，引用数据类型都会返回object，typeof的返回结果有：number、string、undefined、boolean、object、function六种，都是小写<br>
instanceof：判断对象和构造函数在原型链上是否有关联，有返回true，无返回false，基本数据类型无效<br>
constructor：查看对象对应的构造函数，当我们写一个构造函数的时候程序会自动添加；构造函数名.prototype.constructor=构造函数名；<br>
str.constructor == String;//true<br>
object.prototype.toString.call: 不管是什么类型都能检测出来<br>
7. call和apply,bind的区别？<br>
call、apply、bind的作用是改变函数运行时this的指向</p>
<p>2.js垃圾回收与内存泄漏？<br>
浏览器的JavaScript具有自动垃圾回收机制（GC），即执行环境会负责管理代码执行过程中的内存。原理是：垃圾收集器会定期找出那些不在继续使用的变量，然后将其内存进行释放。</p>
<p>垃圾回收机制标记无用变量的策略有两种：标记清除和引用计数。标记清除较为常用。</p>
<p>不在使用的变量就是生命周期结束的变量，只能是局部变量，因为全局变量的生命周期直到浏览器卸载页面是才会结束。局部变量只在函数的执行过程中存在，在这个过程中会在栈或者堆上为这个局部变量分配相应的空间用来存储他们的值，直到函数结束。但是闭包中由于你不函数的原因，外部函数不能算是结束。</p>
<p>function fn1(){<br>
var obj = {name: &quot;tom&quot;}<br>
}<br>
function fn2(){<br>
var obj = {name:&quot;tom&quot;};<br>
return obj;<br>
}<br>
var a = fn1();<br>
var b = fn2();<br>
上面的例子中，只有fn1中的obj会在调用结束后被垃圾回收机制回收，fn2中的obj不会，因为在fn2的调用过程中，返回的变量被变量b引用，所以不会改块内存不会被释放。</p>
<p>1.标记清除：当变量进入环境时，就将这个变量标记为“进入环境”，当变量离开环境时，将它标记为“离开环境”</p>
<p>function test(){<br>
var a = 10 ;       // 被标记 ，进入环境<br>
var b = 20 ;       // 被标记 ，进入环境<br>
}<br>
test();            // 执行完毕 之后 a、b又被标离开环境，被回收。<br>
2.引用计数：跟踪每个值被引用的次数，引用一次就将次数加1，如果包含这个值的变量又被赋了另外一个值，引用次数就减1，当引用次数为0时，垃圾回收机制就会释放该值所占用的内存。</p>
<p>function test() {<br>
var a = {};    // a指向对象的引用次数为1<br>
var b = a;     // a指向对象的引用次数加1，为2<br>
var c = a;     // a指向对象的引用次数再加1，为3<br>
var b = {};    // a指向对象的引用次数减1，为2<br>
}</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[如何判断数组和类数组？如何将类数组转成数组？]]></title>
        <id>https://liujia12138.github.io/post/ru-he-pan-duan-shu-zu-he-lei-shu-zu-ru-he-jiang-lei-shu-zu-zhuan-cheng-shu-zu/</id>
        <link href="https://liujia12138.github.io/post/ru-he-pan-duan-shu-zu-he-lei-shu-zu-ru-he-jiang-lei-shu-zu-zhuan-cheng-shu-zu/">
        </link>
        <updated>2020-05-06T12:39:45.000Z</updated>
        <content type="html"><![CDATA[<p>var arr = [1,2,3,4];<br>
var likeArr = {<br>
'0':'a',<br>
'1':'b',<br>
'2':'c',<br>
length:3<br>
};<br>
1.判断数组类型：<br>
arr instanceof Array;//true<br>
Array.isArray(arr);//true<br>
Object.prototype.toString.call(arr); //'[object Array]'<br>
2.将类数组转成数组<br>
1.[].slice.call()<br>
var fn = function(likeArr){<br>
var arr = Array.prototype.slice.call(likeArr);<br>
//或者：var arr = [].slice.call(arguments);<br>
return arr;<br>
}<br>
2.Array.from()<br>
var fn = function(likeArr){<br>
var arr = Array.from(likeArr)<br>
return arr;<br>
}<br>
3.扩展运算符(...)<br>
//转换arguments<br>
var fn = function(){<br>
var args = [...arguments];<br>
}<br>
兼容写法<br>
function toArray(likeArr){<br>
if(Array.from){<br>
return Array.from(likeArr)<br>
}else{<br>
return [].slice.call(likeArr)<br>
}<br>
}</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[浏览器兼容问题]]></title>
        <id>https://liujia12138.github.io/post/liu-lan-qi-jian-rong-wen-ti/</id>
        <link href="https://liujia12138.github.io/post/liu-lan-qi-jian-rong-wen-ti/">
        </link>
        <updated>2020-05-06T12:39:20.000Z</updated>
        <content type="html"><![CDATA[<p>1.ie8不支持background-size设置背景图大小<br>
用filter：</p>
<p>filter: progid:DXImageTransform.Microsoft.AlphaImageLoader(enabled='true', src='背景图url', sizingMethod='scale');<br>
参数:<br>
1.enabled：设置或检索滤镜是否激活，true/false，默认为true<br>
2.src：图片地址<br>
3.sizingMethod：设置或检索滤镜作用的对象的图片在容器边界内的显示方式，crop剪切/image默认值/scale缩放图片</p>
<p>2.ie8支持的伪类选择器只有:hover,:focus,:first-child<br>
想实现li:nth-of-type(2)只能用li:first-child+li</p>
<p>3.sfaire浏览器中input如果设置了高度，输入的时候光标就会跑到上面去了，所以要用padding撑开<br>
4.ie8不支持placeholder属性，用js实现<br>
1.先判断浏览器是否支持placeholder属性，如果不支持就模拟placeholder<br>
2.创建一个label标签：<label>密码：<label/>标签里的内容为placeholder属性值，再讲标签覆盖到对应的input上</p>
<p>; (function (win) {</p>
<pre><code>win.isPlaceholer = function () {
    var input = document.createElement(&quot;input&quot;);
    return &quot;placeholder&quot; in input;
};

win.placeholder = function () {

    if (!isPlaceholer()) {
        var Placeholder =function (obj) {
            this.input = obj;
            var te = obj.getAttribute('placeholder');
            this.label = document.createElement('label');
            this.label.innerHTML = te;
            this.label.id = obj.id + 'Label';
            this.label.style.cssText = 'position:absolute; text-indent:4px;color:#999999; font-size:14px;';
            if (obj.value !== '') {
                this.label.style.display = 'none';
            }
            this.init();
        };
        Placeholder.prototype = {

            getxy: function (obj) {
                var left, top;
                if (document.documentElement.getBoundingClientRect) {
                    var html = document.documentElement,
                    body = document.body,
                    pos = obj.getBoundingClientRect(),
                    st = html.scrollTop || body.scrollTop,
                    sl = html.scrollLeft || body.scrollLeft,
                    ct = html.clientTop || body.clientTop,
                    cl = html.clientLeft || body.clientLeft;
                    left = pos.left + sl - cl;
                    top = pos.top + st - ct;
                } else {
                    while (obj) {
                        left += obj.offsetLeft;
                        top += obj.offsetTop;
                        obj = obj.offsetParent;
                    }
                }
                return {
                    left: left,
                    top: top
                };
            },

            getwh: function (obj) {
                return {
                    w: obj.offsetWidth,
                    h: obj.offsetHeight
                };
            },

            setStyles: function (obj, styles) {
                for (var p in styles) {
                    obj.style[p] = styles[p] + 'px';
                }
            },
            init: function () {
                var label = this.label,
                input = this.input,
                getXY = this.getxy,
                xy = this.getxy(input),
                wh = this.getwh(input);
                this.setStyles(label, { 'width': wh.w, 'height': wh.h, 'lineHeight': 40, 'left': xy.left + 8, 'top': xy.top });
                document.body.appendChild(label);
                label.onclick = function () {
                    this.style.display = &quot;none&quot;;
                    input.focus();
                };
                input.onfocus = function () {
                    label.style.display = &quot;none&quot;;
                };
                input.onblur = function () {
                    if (this.value === &quot;&quot;) {
                        label.style.display = &quot;block&quot;;
                    }
                };
                if (window.attachEvent) {
                    window.attachEvent(&quot;onresize&quot;, function () {
                        var xy = getXY(input);
                        Placeholder.prototype.setStyles(label, { 'left': xy.left + 8, 'top': xy.top });
                    });
                } else {
                    window.addEventListener(&quot;resize&quot;, function () {
                        var xy = getXY(input);
                        Placeholder.prototype.setStyles(label, { 'left': xy.left + 8, 'top': xy.top });
                    }, false);
                }
            }
        };

        var inpColl = $(&quot;#Box input:visible&quot;);//这里是页面上要添加placeholder支持的input
        //var inpColl = document.getElementsByTagName('input'),          
        var textColl = document.getElementsByTagName('textarea');//这里是页面上要添加placeholder支持的textarea
        //var lableArr = $(&quot;#Box lable&quot;);
        var toArray = function (coll) {
            for (var i = 0, a = [], len = coll.length; i &lt; len; i++) {
                a[i] = coll[i];
            }
            return a;
        };
        var inpArr = toArray(inpColl),
        textArr = toArray(textColl),

        placeholderArr = inpArr.concat(textArr);
        for (var i = 0; i &lt; placeholderArr.length; i++) {
            if (placeholderArr[i].getAttribute('placeholder') !== null) {

                new Placeholder(placeholderArr[i]);
            }
        }
    }

};
</code></pre>
<p>}(window));<br>
5.ie8不支持css3动画<br>
6.element-ui在火狐浏览器下的滚动问题<br>
用<el-scrollbar></el-scrollbar>组件</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[CSS预处理器，sass、less、stylus]]></title>
        <id>https://liujia12138.github.io/post/css-yu-chu-li-qi-sasslessstylus/</id>
        <link href="https://liujia12138.github.io/post/css-yu-chu-li-qi-sasslessstylus/">
        </link>
        <updated>2020-05-06T12:38:58.000Z</updated>
        <content type="html"><![CDATA[<p>css预处理器是一种专门用来为css增加编程特性的编程语言，css本身不是编程语言。</p>
<p>css预处理器的作用：</p>
<p>css语法不够强大，选择器无法嵌套，导致css中存在较多重复的选择器语句；<br>
css无法定义变量，没有合理的样式复用机制，css预处理器为css提供样式复用机制，减少css代码冗余，提高css可维护性；<br>
工作流程（以sass为例）：</p>
<p>以sass提供的语法规则编写样式；<br>
编译器把sass代码转换成标准的css代码；<br>
浏览器加载解析后的css样式；<br>
主流css预处理器：</p>
<p>sass：最早最成熟的css预处理器，有两种语法，分别以.sass和.scss为扩展名，scss兼容css3<br>
less<br>
stylus：主要用来给node项目进行css预处理，以.styl为扩展名</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[前端六大排序算法]]></title>
        <id>https://liujia12138.github.io/post/qian-duan-liu-da-pai-xu-suan-fa/</id>
        <link href="https://liujia12138.github.io/post/qian-duan-liu-da-pai-xu-suan-fa/">
        </link>
        <updated>2020-05-06T12:38:32.000Z</updated>
        <content type="html"><![CDATA[<p>1.冒泡排序<br>
原理：比较相邻两个数的大小，将较大（或小）的数换到右边（或左边），这样就能将最大（或最小）的数一个一个的比较出来，放到一端。循环这个过程，将所有的数字的顺序排列出来。<br>
数组长度为n，总共要进行n-1趟，每第i趟的排序次数为n-i-1次<br>
时间复杂度：O(n^2)；空间复杂度O(1)</p>
<p>function bubbleSort(arr){<br>
for(var i = 0; i&lt;arr.length-1; i++){//冒泡次数<br>
for(var j = 0; j &lt; arr.length - i -1; j++){<br>
if(arr[j] &gt; arr[j+1]){<br>
let temp = arr[j];<br>
arr[j] = arr[j+1];<br>
arr[j+1] = temp;<br>
}<br>
}<br>
}<br>
return arr<br>
}<br>
2.选择排序<br>
原理：先找出数组中最大（或最小）的值，放到一头，然后重复这个过程<br>
时间复杂度：O(n^2)</p>
<p>function selectSort(arr){<br>
for(var i = 0; i&lt; arr.length-1; i++){//循环次数<br>
for(var j = i+1; j &lt; arr.length; j++){<br>
if(arr[i] &gt; arr[j]){<br>
var tmp = arr[i];<br>
arr[i] = arr[j];<br>
arr[j] = tmp<br>
}<br>
}<br>
}<br>
return arr<br>
}<br>
3.插入排序<br>
原理：构建有序序列，对于未排序数据，在已排序的序列中从后向前扫描，找到相应的位置并插入。<br>
默认该有序数列的第一个值是数组的第一个元素，i从1开始取，arr[i]和 arr[0]到arr[i] 之间的数进行比较，找到自己的位置</p>
<p>function insertSort(arr){<br>
for(var i = 1; i&lt; arr.length; i++){<br>
let j = i;<br>
while(j &gt;=0 ){<br>
if(arr[j] &lt; arr[j-1]){<br>
var temp = arr[j];<br>
arr[j] = arr[j-1];<br>
arr[j-1] = temp;<br>
}<br>
j--;<br>
}<br>
}<br>
return arr<br>
}<br>
4.希尔排序<br>
原理：简单插入排序的改进版。与插入排序的不同之处在于，它会优先比较距离较远的元素。希尔排序又叫缩小增量排序。</p>
<p>5.归并排序<br>
原理：归并排序是采用分治法的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，成为2-路归并。</p>
<p>6.快速排序<br>
原理：设置一个基准数，将基准数交换到数组的末尾，遍历数组，将小于基准数的换到左边，大于基准数的换到右边，然后将基准数换到他们中间，这成为分区。快排就是不断分区的过程，完成第一个分区后，再对左右两边分成的数组进行分区，一直重复到排序完成。</p>
<p>function quickSort(arr){<br>
var len = arr.length;<br>
if(len&lt;=1){<br>
return arr<br>
}<br>
var pivotIndex = Math.floor(len/2);<br>
var pivot = arr.splice(pivotIndex, 1)[0];<br>
var left = [], right = [];<br>
for(var i = 0; i &lt; len; i++){<br>
if(arr[i] &lt; pivot){<br>
left.push(arr[i] )<br>
}else{<br>
right.push(arr[i] )<br>
}<br>
}<br>
return quickSort(left).concat([pivot], quickSort(right))<br>
}</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[为什么页面写了setTimeout要在页面销毁时清除这个timeout？]]></title>
        <id>https://liujia12138.github.io/post/wei-shi-me-ye-mian-xie-liao-settimeout-yao-zai-ye-mian-xiao-hui-shi-qing-chu-zhe-ge-timeout/</id>
        <link href="https://liujia12138.github.io/post/wei-shi-me-ye-mian-xie-liao-settimeout-yao-zai-ye-mian-xiao-hui-shi-qing-chu-zhe-ge-timeout/">
        </link>
        <updated>2020-05-06T12:38:05.000Z</updated>
        <content type="html"><![CDATA[<p>vue、react等创建的单页面应用，切换路由的时候并不会刷新页面，定时器也不会被销毁，所以需要在beforeDestroy中手动清除；</p>
<p>用setTimeout实现setInterval？</p>
<p>var t = null;<br>
var count = 0;<br>
function time(){<br>
clearTimeout(t);<br>
count ++;<br>
t = setTimeout(time, 1000);<br>
}<br>
t = setTimeout(time, 1000);<br>
var t = null;<br>
function f(fn, time){<br>
var _this = this;<br>
var args = [...arguments].slice(2)<br>
function setFun(){<br>
clearTimeout(t);<br>
t = setTimeout(function(){<br>
setFun();<br>
fn(args);<br>
}, time)<br>
}<br>
setFun();<br>
}</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[css实现宽高比]]></title>
        <id>https://liujia12138.github.io/post/css-shi-xian-kuan-gao-bi/</id>
        <link href="https://liujia12138.github.io/post/css-shi-xian-kuan-gao-bi/">
        </link>
        <updated>2020-05-06T12:37:43.000Z</updated>
        <content type="html"><![CDATA[<p>垂直方向的padding+calc<br>
借助padding-top或者padding-bottom的百分比值来实现容器的宽高比，padding的百分比值是根据外层容器的宽度计算的，我们只需要设置好外层容器的宽度，并将容器的高度设置为0，容器所有子元素都设置绝对定位。</p>
<!-- html如下 -->
<div class='container'>
    <div class='aspectration' data-ratio='4:3'>
        <div class='content'></div>
    </div>
</div>
.container{
    width: 300px;
}
.aspectration{
    width: 100%;
    position: relative;
    height: 0;
}
.aspectration[data-ratio='4:3']{
    padding-top: calc(100% / 4 * 3);
}
.aspectration>*{
    position: absolute;
    width: 100%;
    height: 100%;
    left: 0;
    top: 0;
}]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[盒模型宽高值的计算方式，边界塌陷，负值作用，box-sizing概念]]></title>
        <id>https://liujia12138.github.io/post/he-mo-xing-kuan-gao-zhi-de-ji-suan-fang-shi-bian-jie-ta-xian-fu-zhi-zuo-yong-box-sizing-gai-nian/</id>
        <link href="https://liujia12138.github.io/post/he-mo-xing-kuan-gao-zhi-de-ji-suan-fang-shi-bian-jie-ta-xian-fu-zhi-zuo-yong-box-sizing-gai-nian/">
        </link>
        <updated>2020-05-06T12:37:18.000Z</updated>
        <content type="html"><![CDATA[<p>box-sizing用来告诉浏览器如何计算一个元素的宽度和高度；<br>
盒子的四个组成区域：内容content、内边距padding、边框border、外边距margin</p>
<p>box-sizing有三个属性值：content-box、border-box、inherit</p>
<p>标准盒模型：box-sizing:content-box;<br>
元素的总宽度和总高度就是内容的宽度和高度；</p>
<p>IE盒模型：box-sizing:border-box；<br>
元素的总宽度包括内容，内边距和边框</p>
<p>总结：</p>
<p>对于给定width和height的元素，设置box-sizing会影响盒子的content width和content height。<br>
浏览器默认使用content-box，我们设置的宽高就是内容的宽高。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[vue项目安装sass-loader]]></title>
        <id>https://liujia12138.github.io/post/vue-xiang-mu-an-zhuang-sass-loader/</id>
        <link href="https://liujia12138.github.io/post/vue-xiang-mu-an-zhuang-sass-loader/">
        </link>
        <updated>2020-05-06T12:36:12.000Z</updated>
        <content type="html"><![CDATA[<p>安装sass依赖包<br>
npm install sass-loader --save-dev<br>
安装node-sass，因为sass-loader依赖于node-sass<br>
npm install node-sass --save-dev<br>
在build文件夹下的webpack.base.conf.js的rules里面添加配置<br>
{<br>
test: &quot;sass&quot;,<br>
loader: ['style', 'css', 'sass']<br>
}</p>
]]></content>
    </entry>
</feed>