<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://liujia12138.github.io</id>
    <title>AzhA</title>
    <updated>2023-06-13T09:12:01.173Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://liujia12138.github.io"/>
    <link rel="self" href="https://liujia12138.github.io/atom.xml"/>
    <subtitle>温故而知新</subtitle>
    <logo>https://liujia12138.github.io/images/avatar.png</logo>
    <icon>https://liujia12138.github.io/favicon.ico</icon>
    <rights>All rights reserved 2023, AzhA</rights>
    <entry>
        <title type="html"><![CDATA[如何在vue项目中用Express做中间层]]></title>
        <id>https://liujia12138.github.io/post/ru-he-zai-vue-xiang-mu-zhong-yong-express-zuo-zhong-jian-ceng/</id>
        <link href="https://liujia12138.github.io/post/ru-he-zai-vue-xiang-mu-zhong-yong-express-zuo-zhong-jian-ceng/">
        </link>
        <updated>2022-10-24T09:50:20.000Z</updated>
        <content type="html"><![CDATA[<p>背景：在已有的vue2项目中，需要进行BFF开发，进行数据聚合和接口转发。为便于代码管理，将Express项目和前端放在一个代码仓库内，不进行拆分。</p>
<h3 id="一-在项目根目录下新建server目录并进入到server目录内">一、在项目根目录下新建server目录，并进入到server目录内</h3>
<h3 id="二-初始化项目">二、初始化项目</h3>
<h4 id="1初始化">1.初始化</h4>
<p><code>npm init</code><br>
为了避免依赖会有版本冲突，Express单独维护自己的node_modules</p>
<h4 id="2安装express">2.安装express</h4>
<p><code>npm i express --save</code></p>
<h4 id="3安装typescript">3.安装typescript</h4>
<p>安装typescript、ts-node（用来监听ts文件的变化并更新服务），node和express的声明文件@types/node @types/express<br>
<code>npm i typescript ts-node @types/express @types/node -D</code></p>
<h4 id="4-ts环境配置">4. ts环境配置</h4>
<p>新建tsconfig.json文件</p>
<pre><code class="language-json">{
        // 指定需要编译文件 否则默认当前目录下除了exclude之外的所有.ts, .d.ts,.tsx 文件
        &quot;include&quot;:[&quot;app.ts&quot;],
        &quot;compilerOptions&quot;: {
            // 指定使用的模块 ：commonjs amd system cmd  or es2015
            &quot;module&quot;: &quot;commonjs&quot;,
              /* 注意：如果未指定--lib，则会注入默认的librares列表。注入的默认库为：
                对于 --target ES5: DOM,ES5,ScriptHost
                对于 --target ES6: DOM,ES6,DOM.Iterable,ScriptHost
                TS 绝不会在您的代码中注入polyfill,所以需要你自己制定编译lib */
            &quot;lib&quot;: [&quot;ESNext&quot;],
             // 指定 ECMAScript 目标版本: 'ES3' (default), 'ES5', 'ES2015', 'ES2016'，'ES2017', or 'ESNEXT'
            &quot;target&quot;: &quot;ES6&quot;,
            // 编译输入文件存放的目录
            &quot;outDir&quot;: &quot;build&quot;,
            // 是否生成.map文件
            &quot;sourceMap&quot;: true,
            &quot;esModuleInterop&quot;: true,
            &quot;forceConsistentCasingInFileNames&quot;: true,
            &quot;strict&quot;: true,
            /* Strict Type-Checking Options */
            // 严格模式将会打开下面的几个选项
            &quot;strict&quot;: false, 
            /* 不允许变量或函数参数具有隐式any类型,例如
            function(name) {
                return name;
            } */
            &quot;noImplicitAny&quot;: true,
            // null类型检测,const teacher: string = null;会报错
            &quot;strictNullChecks&quot;: true,
            // 对函数参数进行严格逆变比较
            &quot;strictFunctionTypes&quot;: true,
            // 严格检查bind call apply
            &quot;strictBindCallApply&quot;: true,
            // 此规则将验证构造函数内部初始化前后已定义的属性。
            &quot;strictPropertyInitialization&quot;: true,
            // 检测this是否隐式指定
            &quot;noImplicitThis&quot;: true,
            // 使用js的严格模式,在每一个文件上部声明 use strict
            &quot;alwaysStrict&quot;: true,
            /* Additional Checks */
            // 默认false,是否检测定义了但是没使用的变量
            &quot;noUnusedLocals&quot;: true,
            // 用于检查是否有在函数体中没有使用的参数
            &quot;noUnusedParameters&quot;: true,
            // 用于检查函数是否有返回值，设为true后，如果函数没有返回值则会提示
            &quot;noImplicitReturns&quot;: true,
            // 用于检查switch中是否有case没有使用break跳出switch
            &quot;noFallthroughCasesInSwitch&quot;: true,
        }
}
</code></pre>
<h3 id="5-新建controller目录用来管理路由">5. 新建controller目录，用来管理路由</h3>
<p>创建article.ts文件，定义文章相关的路由</p>
<pre><code class="language-js">import express from 'express'
import {Response, Request} from 'express'

const router = express.Router()

// 文章分类列表
// 路由处理函数一般会有读写数据库的操作，一般会抽离出来，单独在service目录下管理
router.get('/cates/list', function(req:Request, res:Response)=&gt;{
    // do something
    res.send({
        code: 0,
        msg: 'success',
        data:[]
    })
})

export default router
</code></pre>
<h4 id="6-server目录下新建入口文件-appts">6. server目录下新建入口文件 app.ts</h4>
<pre><code class="language-js">import express from 'express'
import articleRouter from './controller/artcate''
import mw from './middleware'

const app = express()

app.use('/article', articleRouter)

// 错误级别中间件
app.use(mw.errorHandler)

app.listen(3007, () =&gt; {
  console.log('api server is running at http://127.0.0.1:3007')
})
</code></pre>
<h4 id="7packagejson中新增启动脚本">7.package.json中新增启动脚本</h4>
<pre><code class="language-js">&quot;script&quot;:{
    &quot;dev&quot;: &quot;nodemon app.ts&quot;
}
</code></pre>
<p>此时运行<code>npm run dev</code>，在postman中就可以正常请求/article/cates/list 接口了</p>
<h3 id="三-公共配置">三、公共配置</h3>
<h4 id="1-日志输出">1. 日志输出</h4>
<p>安装pino和dayjs<br>
<code>npm i pino pino-pretty dayjs --save</code><br>
<code>npm i @types/pino -D</code></p>
<p>异常监控 Sentry</p>
<h4 id="2-统一响应参数">2. 统一响应参数</h4>
<p>新建const目录，用于存放常量。在const目录下新建code.ts用于存放相应参数，包括status、code和message</p>
<pre><code class="language-js">export enum HTTP_CODE {
  SUCCESS = 0,
  BAD_REQUEST = 400,
  UNAUTHORIZED = 401,
  NOT_FOUND = 404,
  BAD_SERVER = 500,
  NOT_IMPLEMENTED = 501,
  BAD_GATEWAY = 502,
  UNAVAILABLE = 503
}

export enum CODE_MESSAGE {
  SUCCESS = 'success',
  BAD_REQUEST = 'BAD_REQUEST',
  UNAUTHORIZED = '未授权',
  NOT_FOUND = '404',
  BAD_SERVER = '请求异常',
  NOT_IMPLEMENTED = 'NOT_IMPLEMENTED',
  BAD_GATEWAY = 'BAD_GATEWAY',
  UNAVAILABLE = 'UNAVAILABLE'
}

// 状态类型 只能是Code中所枚举的状态
export type CODE_TYPE = keyof typeof HTTP_CODE
</code></pre>
<p>utils目录下新建commonRes.ts ，对响应进行统一处理</p>
<pre><code class="language-js">import { Console } from 'console'
import { Response } from 'express'
import { HTTP_CODE, CODE_MESSAGE, CODE_TYPE } from '../common/const/code'
import logger from './logger'

interface ResOption {
  type?: CODE_TYPE
  message?: string
  status?: number
}

// 默认成功响应
function commonRes(res: Response, data: any, options?: ResOption) {
  options = Object.assign({ type: HTTP_CODE[0] }, options || {}) // 默认success

  const { type, status, message } = options

  let resStatus = status

  if (resStatus === undefined) {
    // 根据状态设置状态码
    resStatus = type === HTTP_CODE[3000] ? 200 : 409
  }

  // 响应参数
  const sendRes: { code: number; data: any; message?: string } = {
    code: HTTP_CODE[type as CODE_TYPE],
    data
  }

  // 响应描述
  message &amp;&amp; (sendRes.message = message)

  return res.status(resStatus).send(sendRes)
}

// 错误响应
commonRes.error = function (
  res: Response,
  data: unknown,
  status: number,
  message?: unknown
) {
  const type = HTTP_CODE[status]
  const msg = message || (CODE_MESSAGE[type] as string)

  logger.error(msg)

  this(res, data, {
    type: type,
    message: msg,
    status: status
  })
}

// 无权限响应
commonRes.denied = function (res: Response, data: unknown) {
  this(res, data, {
    type: 'UNAUTHORIZED',
    message: CODE_MESSAGE['UNAUTHORIZED'],
    status: 401
  })
}

export default commonRes

</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[如何优化webpack配置]]></title>
        <id>https://liujia12138.github.io/post/ru-he-you-hua-webpack-pei-zhi/</id>
        <link href="https://liujia12138.github.io/post/ru-he-you-hua-webpack-pei-zhi/">
        </link>
        <updated>2022-10-18T13:04:57.000Z</updated>
        <content type="html"><![CDATA[<p>优化webpack配置可以从两个角度着手，构建速度和构建物体积</p>
<h2 id="一-优化构建速度">一、优化构建速度</h2>
<h3 id="1-安装speed-measure-webpack-plugin插件">1. 安装speed-measure-webpack-plugin插件</h3>
<p>通过speed-measure-webpack-plugin插件来分析每个loader、plugin消耗的打包时间</p>
<pre><code class="language-js">const SpeedMeasurePlugin = require('speed-measure-webpack-plugin')
const smp = new SpeedMeasurePlugin()
</code></pre>
<p>然后用<code>smp.wrap()</code>包裹webpack配置<br>
注意，如果是用vue-cli构建的项目，要在vue.config.js文件中的configureWebpack用<code>smp.wrap()</code>包裹住webpack配置<br>
<img src="https://liujia12138.github.io/post-images/1666320566092.jpg" alt="" loading="lazy"></p>
<h3 id="2-配置happypack">2. 配置happyPack</h3>
<p>在webpack构建过程中，实际上耗费的时间大多是在loader的解析转换及代码的压缩中。日常开发中我们需要用loader对css、图片、文字等文件做转换和解析的操作，并且转换的文件数据量也非常大。但是由于js天生是单线程的，不能够并发处理这些文件。<br>
<em>happyPack</em> 的作用就是将这些任务分解到多个子进程中去并行处理，子进程处理完后把结果发送到主进程，从而减少总的构建时间</p>
<ol>
<li>安装happypack <code>npm i happypack -D</code></li>
<li>配置</li>
</ol>
<pre><code class="language-js">const HappyPack = require('happypack')
module.exports = {
    // ....
    chainWebpack:(config)=&gt;{
        // 配置loader
        const hRule = config.module.rule('js')
        hRule
        .test(/\.js$/)
        .include.add(resolve('src'))
        .end()
        .uses.clear().end()
        .use('happypack/loader?id=js')
        .loader('happypack/loader?id=js')
        .end()
    },
    configureWebpack:()=&gt;{
        return {
            plugins:[
                // 添加plugin，并开启缓存
                new HappyPack({
                    id: 'js',
                    loaders: ['babel-loader?cacheDirectory=true']
                }),
            ]
        }
    }
}
</code></pre>
<p>通过使用happypack，构建时间由原来的23s降到了11s<br>
<img src="https://liujia12138.github.io/post-images/1666333560180.jpg" alt="" loading="lazy"></p>
<h3 id="3-通过设置路径别名来缩小文件的搜索范围">3. 通过设置路径别名来缩小文件的搜索范围</h3>
<h3 id="4-设置loaders的include和exclude-缩小loader编译的范围">4. 设置loaders的include和exclude 缩小loader编译的范围</h3>
<h3 id="5-extenals结合cdn">5. extenals结合cdn</h3>
<p>用cdn的方式来引入一些依赖，并且设置externals来让webpack在打包的时候忽略掉这些依赖。</p>
<h2 id="二-优化构建物体积">二、优化构建物体积</h2>
<h3 id="1-通过配置webpack-bundle-analyzer-来分析打包后的文件">1. 通过配置webpack-bundle-analyzer 来分析打包后的文件</h3>
<p>webpack-bundle-analyzer会将打包后的内容树展示为树状图，让我们能够方便直观的看到打包后的文件内容和体积大小</p>
<pre><code class="language-js">const BundleAnalyzerPlugin = require('webpack-bundle-analyzer')

module.exports = {
    plugins: [
        new BundleAnalyzerPlugin({
            analyzerHost: '127.0.0.1',
            analyzerPort: 8899
        })
    ]
}
</code></pre>
<p>package.json中加入scripts<code>&quot;analyzer&quot;: &quot;NODE_ENV=production npm_config_report=true npm run build&quot;</code></p>
<h3 id="2-tree-shaking-去掉项目中的无用代码">2. tree-shaking 去掉项目中的无用代码</h3>
<p>目前webpack4.x开始，就已经在mode为production时默认开启了tree-shaking，但是如果想要生效，生成的代码必须是es6模块，不能使用其他类型的模块，如commonjs<br>
修正方法，在.babelrc文件或者webpack.config.js设置module:false<br>
vue-cli构建的项目默认开启了tree-shaking，无需单独配置</p>
<h3 id="3">3.</h3>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[vue中keep-alive的原理]]></title>
        <id>https://liujia12138.github.io/post/vue-zhong-keep-alive-de-yuan-li/</id>
        <link href="https://liujia12138.github.io/post/vue-zhong-keep-alive-de-yuan-li/">
        </link>
        <updated>2022-09-26T08:43:42.000Z</updated>
        <content type="html"><![CDATA[<h3 id="1-keep-alive是什么">1. keep-alive是什么？</h3>
<p>keep-alive是一个抽象组件，他本身不会渲染成一个dom元素，也不会出现在父组件的链式调用中。<br>
keep-alive可以在切换组件时，保存他所包裹的组件的状态，使其不被销毁。</p>
<p>使用场景：<br>
通常在项目中使用标签页切换路由组件这种情况下，我们从列表页点击【修改】某个数据项时，通过系统内打开标签页的方式打开编辑页，进行一些操作后，我们又切回了列表页，我们希望可以保留编辑页内刚刚的操作，这时使用keep-alive就可以解决这种场景。<br>
keep-alive除了可以保存组件状态，还可以避免组件被反复创建和渲染，可以有效提升系统性能。</p>
<h3 id="2-keep-alive的用法">2. keep-alive的用法</h3>
<p>keep-alive对外提供了三个属性，include/exclude/max 。两个生命周期，activated/deactivated。<br>
include：对哪些进行缓存<br>
exclude：对哪些不进行缓存<br>
max：最多缓存多少个</p>
<h3 id="3-源码解析">3. 源码解析</h3>
<pre><code class="language-js">export default{
	name:'keep-alive',

	abstract:true, //判断当前组件虚拟dom是否渲染成真实dom的关键

	props:{
		include:patternTypes, //缓存白名单
		exclude：patternTypes, //缓存黑名单
		max:[string,number], //混存的组件实例数量上限
	},

	created(){
		this.cache = Object.create(null) //缓存虚拟dom
		this.keys = [] //缓存的虚拟dom的键集合
	},

	destroyed(){
		for(const key in this.cache){ //删除所有缓存
			pruneCachEntry(this.cache,key,this.keys)
		}
	},

	mounted(){
		// &lt;!-- 实时监听黑白名单的变动 --&gt;
		this.$watch('include',val =&gt; {
			pruneCache(this,name =&gt; matches(val,name))
		})

		this.$watch('exclude',val =&gt; {
			pruneCache(this,name =&gt; matches(val,name))
		})
	},

	render(){
		const slot = this.$slots.default
		const vnode:VNode = getFirstComponentChild(slot); //找到第一个子组件对象
		const componentOptions:?VNodeComponentOptions = vnode &amp;&amp; vnode.componentOptions

		if(componentOptions){ //存在组件参数
			&lt;!-- check pattern --&gt;
			const name:?string = getComponent(componentOptions) //组件名称
			const {include,exclude} = this;

			&lt;!-- 条件匹配 --&gt;
			if((include &amp;&amp; (!name || !matches(include,name))) || (exclude &amp;&amp; name &amp;&amp; matches(exclude,name))){
				return vnode
			}


			const {cache ,keys} = this;

			&lt;!-- 定义组件的缓存key --&gt;
			const key:?string = vnode.key == null  ？ componentOptions.Ctor.cid + (componentOptions.tag ? `::${componentOptions.tag}`) : vnode.key

			&lt;!-- 已经缓存过的组件 --&gt;
			if(cache[key]){
				vnode.componentInstance = cache[key].componentInstance
				remove(keys,key)
				keys.push(key) //调整key排序
			}else{
				cache[key] = vnode //缓存组件对象
				keys.push(key)

				if(this.max &amp;&amp; keys.length &gt; parseInt(this.max)){ //超过缓存数限制，将第一个删除
					pruneCacheEntry(cache,keys[0],keys,this._vnode)
				}
			}
		}
	vnode.data.keepAlive = true //渲染和执行被包裹组件的钩子函数需要用到
	}

	return vnode || (slot &amp;&amp; slot[0])
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[如何做到执行JS 而不影响页面的css加载？]]></title>
        <id>https://liujia12138.github.io/post/ru-he-zuo-dao-zhi-xing-js-er-bu-ying-xiang-ye-mian-de-css-jia-zai/</id>
        <link href="https://liujia12138.github.io/post/ru-he-zuo-dao-zhi-xing-js-er-bu-ying-xiang-ye-mian-de-css-jia-zai/">
        </link>
        <updated>2022-09-26T07:34:38.000Z</updated>
        <content type="html"><![CDATA[<h4 id="加载js为什么会影响css的加载">加载JS为什么会影响CSS的加载？</h4>
<p>因为js是单线程的，所以当js的加载在css前时，会导致css加载被阻塞，造成UI渲染的卡顿。</p>
<h4 id="什么是web-worker">什么是Web Worker</h4>
<p>web worker的作用就是为JavaScript创造一个多线程的环境，允许主线程创建worker线程，将一个任务分配给worker线程运行。在主线程运行的同时，worker线程在后台运行，两者互不干扰。</p>
<h4 id="如何使用web-worker">如何使用Web Worker</h4>
<h5 id="1-使用web-worker需要注意的点">1. 使用web worker需要注意的点：</h5>
<pre><code>1. 同源限制：分配给Worker线程运行的脚本文件，必须与主线程的脚本文件同源
2. DOM限制：Worker线程所在的全局对象无法读取主线程所在网页的DOM对象，也无法使用DOM的相关API，但是Worker线程可以使用navigator和location对象
3. 通信联系：Worker线程和主线程不在同一个上下文环境，所以无法直接通信，需要使用postMessage
4.  脚本限制：Worker线程不能执行alert方法和confirm方法，但是可以使用XMLHttpRequest发起请求
5.  文件限制：worker无法读取本地文件，他所加载的文件必须来自网络
</code></pre>
<h5 id="2-基本用法">2. 基本用法</h5>
<ol>
<li>
<p>创建一个Worker线程，主线程使用new关键字调用Worker构造函数<br>
<code>var worker = new Worker('work.js')</code><br>
Worker构造函数的参数是一个脚本文件，该文件的内容就是Worker线程要执行的任务。由于worker不能读取本地文件，所以这个文件必须来自网络。</p>
</li>
<li>
<p>主线程向worker线程发消息<br>
主线程调用worker.postMessage方法，向Worker发消息</p>
<pre><code class="language-js">worker.postMessage({method:'echo', args:['work']})
</code></pre>
</li>
<li>
<p>worker线程内 接收/发送 消息<br>
通过监听message事件和postMessage方法</p>
<pre><code class="language-js">// self代表worker子线程自身
self.addEventListener('message', function(e){
   // e.data 可以获取到主线程发送的数据

   self.postMessage('send some message')
})
</code></pre>
</li>
<li>
<p>主线程接收worker线程的消息<br>
调用worker的onmessage方法</p>
</li>
</ol>
<pre><code class="language-js">  worker.onmessage = function(event){
      // event.data可以获取到worker发来的数据
      console.log(event.data)
      // do something
  }
</code></pre>
<ol start="5">
<li>关闭worker线程<br>
主线程： <code>worker.terminate()</code><br>
worker线程： <code>self.close()</code></li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[vue打包性能优化]]></title>
        <id>https://liujia12138.github.io/post/vue2vue-cli4da-bao-xing-neng-you-hua/</id>
        <link href="https://liujia12138.github.io/post/vue2vue-cli4da-bao-xing-neng-you-hua/">
        </link>
        <updated>2022-09-26T06:09:17.000Z</updated>
        <content type="html"><![CDATA[<h3 id="1-路由懒加载和分模块打包">1. 路由懒加载和分模块打包</h3>
<p>import()+ webpackChunkName</p>
<h3 id="2-开启-gzip-压缩">2. 开启 Gzip 压缩</h3>
<p>安装 CompressionWebpackPlugin，<code>npm i compression-webpack-plugin --save-dev</code><br>
在 vue.config.js 中配置</p>
<pre><code class="language-js">module.exports = {
  // ....
  configureWebpack: (config) =&gt; {
    if (process.env.NODE_ENV === 'production') {
      const CompressionWebpackPlugin = require('compression-webpack-plugin')
      const productionGzipExtensions = ['html', 'js', 'css']
      config.plugins.push(
        new CompressionWebpackPlugin({
          filename: '[path].gz[query]',
          algorithm: 'gzip',
          test: new RegExp('\\.(' + productionGzipExtensions.join('|') + ')$'),
          // 文件大小超过1k才会被压缩
          threshold: 1024,
          minRatio: 0.99,
          // 删除源文件
          deleteOriginAssets: true
        })
      )
    }
  }
}
</code></pre>
<h3 id="3-icon-图片转-base64">3. icon 图片转 base64</h3>
<p>使用 file-loader 和 url-loader</p>
<pre><code class="language-js"> {
    test: /\.(png|jpe?g|gif|svg)(\?.*)?$/,
    loader: &quot;url-loader&quot;,
    exclude: [resolve(&quot;src/assets/icons&quot;)],
    options: {
      limit: 10000,
      name: utils.assetsPath(&quot;img/[name].[hash:7].[ext]&quot;)
    }
  }
</code></pre>
<h3 id="4-使用-cdn">4. 使用 cdn</h3>
<p>（选配，CDN 虽然速度快，但是没有本地打包稳定）</p>
<pre><code>// 是否为生产环境
const isProduction = process.env.NODE_ENV !== 'development';

// 本地环境是否需要使用cdn
const devNeedCdn = false

// cdn链接
const cdn = {
    // cdn：模块名称和模块作用域命名（对应window里面挂载的变量名称）
    externals: {
        vue: 'Vue',
        vuex: 'Vuex',
        'vue-router': 'VueRouter',
        'marked': 'marked',
        'highlight.js': 'hljs',
        'nprogress': 'NProgress',
        'axios': 'axios'
    },
    // cdn的css链接
    css: [
        'https://cdn.bootcss.com/nprogress/0.2.0/nprogress.min.css'
    ],
    // cdn的js链接
    js: [
        'https://cdn.bootcss.com/vue/2.6.10/vue.min.js',
        'https://cdn.bootcss.com/vuex/3.1.2/vuex.min.js',
        'https://cdn.bootcss.com/vue-router/3.1.3/vue-router.min.js',
        'https://cdn.bootcss.com/marked/0.8.0/marked.min.js',
        'https://cdn.bootcss.com/highlight.js/9.18.1/highlight.min.js',
        'https://cdn.bootcss.com/nprogress/0.2.0/nprogress.min.js',
        'https://cdn.bootcss.com/axios/0.19.2/axios.min.js'
    ]
}

module.exports = {
    chainWebpack: config =&gt; {
        // ============注入cdn start============
        config.plugin('html').tap(args =&gt; {
            // 生产环境或本地需要cdn时，才注入cdn
            if (isProduction || devNeedCdn) args[0].cdn = cdn
            return args
        })
        // ============注入cdn start============
    },
    configureWebpack: config =&gt; {
        // 用cdn方式引入，则构建时要忽略相关资源
        if (isProduction || devNeedCdn) config.externals = cdn.externals
    }
}
</code></pre>
<p>html 中引入 CDN</p>
<pre><code class="language-html">&lt;!-- 使用CDN的CSS文件 --&gt;
&lt;% for (var i in htmlWebpackPlugin.options.cdn &amp;&amp; htmlWebpackPlugin.options.cdn.css) { %&gt;
&lt;link href=&quot;&lt;%= htmlWebpackPlugin.options.cdn.css[i] %&gt;&quot; rel=&quot;stylesheet&quot; /&gt;
&lt;% } %&gt;
&lt;!-- 使用CDN的CSS文件 --&gt;

&lt;!-- 使用cdn的js文件 --&gt;
&lt;% for (var i in htmlWebpackPlugin.options.cdn &amp;&amp; htmlWebpackPlugin.options.cdn.js) { %&gt;
&lt;script src=&quot;&lt;%= htmlWebpackPlugin.options.cdn.js[i] %&gt;&quot;&gt;&lt;/script&gt;
&lt;% } %&gt;
&lt;!-- 使用CDN的js文件 --&gt;
</code></pre>
<h3 id="5-压缩-js-代码">5. 压缩 js 代码</h3>
<p>使用 UglifyjsWebpackPlugin 插件</p>
<ol>
<li>安装``` npm i uglifyjs-webpack-plugin --save-dev ````</li>
<li>在 vue.config.js 中引入</li>
</ol>
<pre><code class="language-js">module.exports = {
  configureWebpack: (config) =&gt; {
    const UglifyjsWebpackPlugin = require('uglifyjs-webpack-plugin')
    config.plugins.push(
      new UglifyjsWebpackPlugin({
        uglifyOptions: {
          // 生产环境自动删除console
          compress: {
            drop_debugger: true,
            drop_console: true,
            pure_funcs: ['console.log']
          }
        },
        sourceMap: false,
        parallel: true
      })
    )
  }
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[JS的作用域、预解析和声明提升]]></title>
        <id>https://liujia12138.github.io/post/js-de-zuo-yong-yu-yu-jie-xi-he-sheng-ming-ti-sheng/</id>
        <link href="https://liujia12138.github.io/post/js-de-zuo-yong-yu-yu-jie-xi-he-sheng-ming-ti-sheng/">
        </link>
        <updated>2022-09-18T07:28:18.000Z</updated>
        <content type="html"><![CDATA[<h3 id="作用域">作用域</h3>
<p>作用域就是变量的有效范围。 在一定的空间里可以对数据进行读写操作，这个空间就是数据的作用域</p>
<h4 id="1-全局作用域">1、全局作用域：</h4>
<p>最外层函数定义的变量拥有全局作用域，即对任何内部函数来说，都是 可以访问的；</p>
<h4 id="2-局部作用域">2、局部作用域：</h4>
<p>局部作用域一般只在固定的代码片段内可访问到，而对于函数外部是无 法访问的，最常见的例如函数内部。在 ES6 之前，只有函数可以划分变量的作用域，所以 在函数的外面无法访问函数内的变量</p>
<h4 id="3-块级作用域">3、块级作用域：</h4>
<p>凡是代码块就可以划分变量的作用域，这种作用域的规则就叫块级作用域</p>
<h4 id="块级作用域-函数作用域-词法作用域之间的区别">块级作用域 函数作用域 词法作用域之间的区别：</h4>
<p>3.1）块级作用域和函数作用域描述的是，什么东西可以划分变量的作用域<br>
3.2）词法作用域描述的是，变量的查找规则<br>
之间的关系：<br>
1、 块级作用域 包含 函数作用域<br>
2、 词法作用域 与 块级作用域、函数作用域之间没有任何交集， 他们从两个角度描述了作用域的规则<br>
ES6 之前 JavaScript 采用的是函数作用域+词法作用域，ES6 js 采用的是块级作用域+词法作用域</p>
<h3 id="预解析">预解析</h3>
<p>JavaScript 代码的执行是由浏览器中的 JavaScript 解析器来执行的。JavaScript 解析器执行 JavaScript 代码的时候，分为两个过程：预解析过程和代码执行过程</p>
<h4 id="预解析过程都发生了什么">预解析过程都发生了什么？</h4>
<ol>
<li>将变量的声明提升到作用域的最前面，只会提升声明，不会提升赋值。</li>
<li>将函数的声明提升到作用域的最前面，只会提升声明，不会提升调用。</li>
<li>函数提升的优先级大于变量提升的优先级</li>
</ol>
<pre><code class="language-js">// 因为var先提升，所以此处的fn是函数fn
console.log(fn);// [Function: fn]
function fn (){
  return 'fn'
}
var fn = 'aaa'
</code></pre>
<h3 id="声明提升">声明提升</h3>
<p>如上面代码，使用var关键字声明的变量，或者使用函数声明创建的函数，可以先使用后声明。<br>
需要注意的是，使用函数表达式的写法创建的函数，不会存在声明提升</p>
<pre><code class="language-js">// 函数表达式
var fn = function(){
    return 'fn'
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[js中如何判断两个对象是否相等]]></title>
        <id>https://liujia12138.github.io/post/js-zhong-ru-he-pan-duan-liang-ge-dui-xiang-shi-fou-xiang-deng/</id>
        <link href="https://liujia12138.github.io/post/js-zhong-ru-he-pan-duan-liang-ge-dui-xiang-shi-fou-xiang-deng/">
        </link>
        <updated>2022-09-18T03:30:26.000Z</updated>
        <content type="html"><![CDATA[<h4 id="1-判断两个对象的引用地址">1、判断两个对象的引用地址</h4>
<p>ES6中，提供了一个方法可以用来判断两个对象的引用地址是否一致：<code>Object.is(value1, value2)</code>。返回值为一个布尔值，如果两个对象引用地址一致则返回值为true，反之则为false</p>
<p>####2、判断两个对象内容一致<br>
想要比较两个对象的内容是否一致，需要遍历对象所有的键名和键值，判断是否完全一致。<br>
实现思路：<br>
1. 先判断两个对象引用地址是否一致<br>
2. 获取对象所有键名的数组，并且判断长度是否一致<br>
3. 遍历键名数组，判断键值是否都相等</p>
<pre><code class="language-js">function isObjectValueEqual(obj1, obj2){
    // 1.判断引用地址是否一致，一致则直接返回true
    if(Object.is(obj1, obj2)) return true
    const props1 = Object.getOwnPropertyNames(obj1)
    const props2 = Object.getOwnPropertyNames(obj2)
    // 2.判断键名数组长度是否一致，不一致则直接返回false
    if(props1.length !== props2.length) return false;
    // 3.键名数组长度一致，遍历键名数组，判断所有值是否一致
    for(let prop in obj1){
        // 3.1判断obj1的键值在obj2中是否存在，存在则进一步判断值，不存在直接返回false
        if(obj2.hasOwnProperty(prop)){
            // 3.2判断obj1的键值是否为对象，是则递归判断，否则直接判断值是否相等
            if(typeof obj1[prop] === 'object'){
                if(!isObjectValueEqual(obj1[prop],obj2[prop])) return false
            }else{
                if(obj1[prop] !== obj2[prop]) return false
            }
        }else{
            return false
        }
    }
    return true
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[JavaScript的内置对象、原生对象、宿主对象分别指的是什么？]]></title>
        <id>https://liujia12138.github.io/post/javascript-de-nei-zhi-dui-xiang-yuan-sheng-dui-xiang-su-zhu-dui-xiang-fen-bie-zhi-de-shi-shi-me/</id>
        <link href="https://liujia12138.github.io/post/javascript-de-nei-zhi-dui-xiang-yuan-sheng-dui-xiang-su-zhu-dui-xiang-fen-bie-zhi-de-shi-shi-me/">
        </link>
        <updated>2022-09-18T02:48:46.000Z</updated>
        <content type="html"><![CDATA[<h3 id="1-内置对象">1、内置对象</h3>
<p>由ECMAScript实现提供的、独立于宿主环境的所有对象。<br>
内置对象在引擎初始化阶段就已经被创建好。<br>
ECMA-262只定义了两个内置对象，即Global和Math。他们也是本地对象，即内置对象其实是本地对象的一种。</p>
<h3 id="2-原生对象">2、原生对象</h3>
<p>ECMA-262将本地对象定义为独立于宿主环境的ECMAScript实现提供对象。<br>
除了内置对象外，原生对象还包括了一些在运行过程中创建的对象。<br>
本地对象包括：Object、Function、Array、String、Number、Boolean、Date、RegExp、Error、EvalError、RangeError、ReferenceError、SyntaxError、TypeError、URLError<br>
由此可以看出，本地对象就是ECMA定义的类。</p>
<h3 id="3-宿主对象">3、宿主对象</h3>
<p>ECMAScript中的宿主就是我们网页所运行的环境，即浏览器和操作系统。<br>
所有的非本地对象都是宿主对象，即由ECMAScript实现的宿主环境提供的对象。<br>
所有的DOM和BOM都是宿主对象。因为其对于不同的宿主环境所展示的内容是不一样的。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[react 和 vue 中的 key 有什么作用？]]></title>
        <id>https://liujia12138.github.io/post/react-he-vue-zhong-de-key-you-shi-me-zuo-yong/</id>
        <link href="https://liujia12138.github.io/post/react-he-vue-zhong-de-key-you-shi-me-zuo-yong/">
        </link>
        <updated>2022-09-13T03:30:44.000Z</updated>
        <content type="html"><![CDATA[<h5 id="一-虚拟-dom-中-key-的作用">一. 虚拟 DOM 中 key 的作用：</h5>
<p>key 是虚拟 DOM 中对象的标识，当数据发生变化时，vue 会根据 新数据 生成 新的虚拟 DOM，随后 Vue 内部会进行 新虚拟 DOM 和 旧的虚拟 DOM 的差异对比（diff 算法）：</p>
<h6 id="对比规则">对比规则：</h6>
<ol>
<li>旧的虚拟 DOM 中找到与新的虚拟 DOM 中具有相同 key 值的 VNode</li>
</ol>
<ul>
<li>若虚拟 DOM 中内容没有发生变化，直接使用 之前的真实DOM，不会改变DOM</li>
<li>若虚拟 DOM 中内容发生了变化，则生成新的真实 DOM，随后替换掉页面中之前的真实 DOM</li>
</ul>
<ol start="2">
<li>旧的虚拟 DOM 中没有找到与新的虚拟 DOM 具有相同 key 值的 VNode<br>
创建新的真实 DOM，然后渲染到页面上</li>
</ol>
<h5 id="二-用-index-作为-key-值可能会引发的问题">二. 用 index 作为 key 值可能会引发的问题？</h5>
<ol>
<li>若对数据进行：逆序添加、逆序删除等破坏原有顺序的操作，会产生没有必要的真实 DOM 更新，页面效果没有问题，但是效率低（因为对数据的顺序进行了改变，导致没有发生变化的数据在渲染时也无法使用之前的真实DOM）</li>
<li>如果结构中还包含了输入类的 DOM，如 input，会产生错误的 DOM 更新，导致页面有问题，如：</li>
</ol>
<pre><code class="language-html">&lt;template&gt;
  &lt;div&gt;
    &lt;button @click=&quot;addPerson&quot;&gt;向列表前添加一个人&lt;/button&gt;
    &lt;ul&gt;
      &lt;li v-for=&quot;(item,index) in persons&quot; :key=&quot;index&quot;&gt;
        {{item.name}}---{{index}}
        &lt;!-- 每人一个输入框 --&gt;
        &lt;input type=&quot;text&quot; /&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
  export default{
    data(){
      return {
        person: [
          {
            name: '张三',
            id: '001'
          },{
            name: '李四',
            id: '002'
          },{
            name: '王五',
            id: '003'
          }
        ]
      }
    },
    methods:{
      addPerson(){
        let p = {
          name: '老刘',
          id: '004
        }
        this.person.upshift(p)
      }
    }
  }
&lt;/script&gt;
</code></pre>
<p>页面渲染出persons列表后在每行的input中输入姓名<br>
效果图:<br>
<img src="https://liujia12138.github.io/post-images/1663040035727.jpg" alt="" loading="lazy"></p>
<p>点击按钮，添加老刘后<br>
<img src="https://liujia12138.github.io/post-images/1663040050410.jpg" alt="" loading="lazy"></p>
<p>此时页面上老刘数据添加到persons的第一位，姓名和index都正常渲染，但是input出现了错位的情况。<br>
这是因为旧的虚拟DOM中张三和新的虚拟DOM中老刘具有相同的key：0，diff算法在进行差异对比时，发现name不同，然后页面渲染时就会渲染上新的name，但是对于input，由于上一步在input中输入姓名的操作是发生在真实DOM中的，没有影响到虚拟DOM，所以，在进行对比时会认为这一部分没有发生变化，这时页面就会继续使用上一次渲染的input，这也就导致了‘老刘’这条数据在页面上的input是张三的。</p>
<p>对比过程图<br>
<img src="https://liujia12138.github.io/post-images/1663040060872.jpg" alt="" loading="lazy"></p>
<h5 id="三开发中如何选择key">三.开发中如何选择key？</h5>
<ol>
<li>最好使用每条数据的唯一标识作为key，比如id，手机号，身份证号等唯一值</li>
<li>如果不存在对数据逆序添加、逆序删除等破坏顺序的操作，仅用于渲染列表展示，使用index作为key是不会有问题的</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[定时任务时间表达式规则]]></title>
        <id>https://liujia12138.github.io/post/ding-shi-ren-wu-shi-jian-biao-da-shi-gui-ze/</id>
        <link href="https://liujia12138.github.io/post/ding-shi-ren-wu-shi-jian-biao-da-shi-gui-ze/">
        </link>
        <updated>2022-08-10T07:05:16.000Z</updated>
        <content type="html"><![CDATA[<h3 id="为什么需要时间表达式">为什么需要时间表达式</h3>
<p>数据中台项目中，需要定时执行规则来进行数据质量的检核，这个定时的规则通常是用户在后台进行配置的。</p>
<h3 id="定时任务时间表达式规则">定时任务时间表达式规则</h3>
<p>时间表达式组件一般由秒、分、时、日、月、周（星期几）、年7个域组成<br>
对应的生成的表达式也是由 s、m、h、d、M、w、y 7个值由空格拼接生成</p>
<h5 id="各个域的含义和可选值">各个域的含义和可选值：</h5>
<table>
<thead>
<tr>
<th>域</th>
<th style="text-align:center">取值</th>
<th>特殊字符</th>
</tr>
</thead>
<tbody>
<tr>
<td>1.秒</td>
<td style="text-align:center">0-59</td>
<td>, - / *</td>
</tr>
<tr>
<td>2.分</td>
<td style="text-align:center">0-59</td>
<td>, - / *</td>
</tr>
<tr>
<td>3.时</td>
<td style="text-align:center">0-23</td>
<td>, - / *</td>
</tr>
<tr>
<td>4.日</td>
<td style="text-align:center">1-31</td>
<td>, - / * ? L W</td>
</tr>
<tr>
<td>5.月</td>
<td style="text-align:center">1-12</td>
<td>, - / *</td>
</tr>
<tr>
<td>6.周</td>
<td style="text-align:center">1-7或SUN-SAT</td>
<td>, - / * ? L</td>
</tr>
<tr>
<td>7.年</td>
<td style="text-align:center">1970-2099</td>
<td>, - / *</td>
</tr>
</tbody>
</table>
<h5 id="特殊字符的含义">特殊字符的含义</h5>
<p>* : 表示匹配该域的任意值。比如Minutes域使用*，就表示每分钟都会触发。<br>
- : 表示范围。比如Minutes域使用 10-20，就表示从10分钟到20分钟每分钟都会触发一次。<br>
, : 表示列出枚举值。比如Minutes域使用1,3，就表示1分钟和3分钟都会触发一次。<br>
/ : 表示间隔时间触发(开始时间/时间间隔)。例如在Minutes域使用 5/10，就表示从第5分钟开始，每隔10分钟触发一次。<br>
? : 表示不指定值。简单理解就是忽略该字段的值，直接根据另一个字段的值触发执行。<br>
# : 表示该月第n个星期x(x#n)，仅用星期域。如：星期：6#3，表示该月的第三个星期五。<br>
L : 表示最后，是单词&quot;last&quot;的缩写（最后一天或最后一个星期几）；仅出现在日和星期的域中。用在日则表示该月的最后一天，用在星期则表示该月的最后一个星期。如：星期域上的值为5L，则表示该月最后一个星期的星期四。在使用'L'时，不要指定列表','或范围'-'，否则易导致出现意料之外的结果。<br>
W: 仅用在日的域中，表示距离当月给定日期最近的工作日（周一到周五），是单词&quot;weekday&quot;的缩写。</p>
]]></content>
    </entry>
</feed>