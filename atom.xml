<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://liujia12138.github.io</id>
    <title>AzhA</title>
    <updated>2020-05-14T13:13:37.160Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://liujia12138.github.io"/>
    <link rel="self" href="https://liujia12138.github.io/atom.xml"/>
    <subtitle>温故而知新</subtitle>
    <logo>https://liujia12138.github.io/images/avatar.png</logo>
    <icon>https://liujia12138.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, AzhA</rights>
    <entry>
        <title type="html"><![CDATA[JavaScript的隐式类型转换]]></title>
        <id>https://liujia12138.github.io/post/javascript-de-yin-shi-lei-xing-zhuan-huan/</id>
        <link href="https://liujia12138.github.io/post/javascript-de-yin-shi-lei-xing-zhuan-huan/">
        </link>
        <updated>2020-05-14T13:12:03.000Z</updated>
        <content type="html"><![CDATA[<ol>
<li>隐式转换规则</li>
</ol>
<ul>
<li>转成string类型： + （字符串拼接符）</li>
<li>转成number类型：++、--、+、-、*、/、%、&lt;、&gt;、&lt;=、&gt;=、!=、<mark>、!</mark>、===</li>
<li>转成boolean类型：!（逻辑非运算符）</li>
</ul>
<ol>
<li>
<p>字符串连接符+：只要+两边有一边是字符串，会吧其他数据类型调用String()方法转换成字符串然后拼接</p>
</li>
<li>
<p>算数运算符+：+两边都是数字，会把其他数据类型调用Number()方法转换成数字然后进行假发运算</p>
</li>
<li>
<p>关系运算符：会把其他数据类型转换成number之后再作比较：</p>
</li>
</ol>
<ul>
<li>
<p>1.当关系运算符两边有一边是字符串的时候，会把字符串转换成number然后比较，比如<code>'a' &gt; 10</code>返回false，<code>'a'&lt;10</code>也返回false，因为Number('a')=NaN</p>
</li>
<li>
<p>2.a. 当关系运算符两边都是字符串的时候，会根据unicode编码来判断，<code>'2' &gt; '10'</code>返回true，因为'2'.charCodeAt()=50, '10'.chaeCodeAt()=49（默认返回第一个字符的编码，如果想要查询第二个字符可以传参下标）； b. 多个字符从左向右依次比较；</p>
</li>
<li>
<p>3.特殊情况，如果数据类型是undefined或者null，得出固定结果</p>
</li>
<li>
<p>4.特殊情况，NaN和任何数据比较都是false，包括NaN；</p>
</li>
<li>
<p>5.复杂数据类型：在隐式转换时会先转成string，然后再转成Number<br>
<img src="http://p9.pstatp.com/large/pgc-image/1538025621414c490c46b28" alt="image" loading="lazy"></p>
</li>
<li>
<ul>
<li>a.先使用valueOf()方法获取原始值，如果原始值不是number类型，则使用toString()方法转成string；</li>
</ul>
</li>
<li>
<ul>
<li>b.再将string转成number（unicode码）运算</li>
</ul>
</li>
</ul>
<pre><code class="language-js">console.log([1, 2] == '1,2');//true, 先获取数组的原始值，然后转成string，然后通过左右两边的字符串的unicode编码运算
console.log([1, 2].valueOf());//[1, 2]
console.log([1, 2].valueOf().toString());//'1,2'

var a = {};
console.log(a == &quot;[object Object]&quot;);//true
console.log(a.valueOf().toString());//&quot;[object Object]&quot;

//声明一个变量a，使下面表达式打印1
var a = {
    i: 1,//声明一个属性i
    valueOf: function(){
        return a.i++;//每调用一次valueOf，让自增1，并且返回i的值
    }
}
if(a == 1 &amp;&amp; a ==2 &amp;&amp; a == 3){
    console.log(1)
}

</code></pre>
<ul>
<li>
<p>6.逻辑非隐式转换与关系运算符隐式转换<br>
**注意：**空数组的toString()方法会得到一个空字符串，而空对象的toString()方法会得到字符串<code>[object Object]</code></p>
</li>
<li>
<ul>
<li>a.关系运算符：将其他数据类型转成number</li>
</ul>
</li>
<li>
<ul>
<li>b.逻辑非!：将其他数据类型使用Boolean()转成布尔值</li>
</ul>
</li>
<li>
<ul>
<li>
<ul>
<li>1.null，undefined，空字符串，0，-0，NaN，false，document.all()转布尔值都会得到false，除此之外全都是true</li>
</ul>
</li>
</ul>
</li>
<li>
<ul>
<li>
<ul>
<li>2.逻辑非运算符优先级高于关系运算符，所以要先得到逻辑非运算结果在进行比较</li>
</ul>
</li>
</ul>
</li>
</ul>
<pre><code class="language-js">console.log([] == 0)//true,
//原理：[].valueOf().toString() =&gt; &quot;&quot;, Number('') == 0

console.log(![] == 0);//true
//原理：逻辑非优先级高于关系运算符，空数组不在上面八种情况里，所以空数组转成布尔值应该是true，![] =&gt; false，false == 0成立

console.log({} == !{});//false
console.log({} == {});//false
//原理：
//1：本质上是{} 与 !{}这个逻辑非表达式比较，!{} =&gt; false，{}.valueOf().toString() =&gt; '[object Object]', 所以{} == !{}不成立，返回false
//2：引用数据类型存储在堆中，栈中存储的是引用地址，所以返回false

console.log([] == ![]);//true
console.log([] == []);//false
//原理：
//1：本质上是比较[]和![]逻辑非运算结果，[].valueOf().toString() =&gt; ''，Number('') =&gt; 0，![] =&gt; false, 0 == false成立，返回true；
//2：引用数据类型，false
</code></pre>
<figure data-type="image" tabindex="1"><img src="https://liujia12138.github.io/post-images/1589461997727.jpeg" alt="" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[移动端屏幕宽度自适应原理及实现]]></title>
        <id>https://liujia12138.github.io/post/yi-dong-duan-ping-mu-kuan-du-zi-gua-ying-yuan-li-ji-shi-xian/</id>
        <link href="https://liujia12138.github.io/post/yi-dong-duan-ping-mu-kuan-du-zi-gua-ying-yuan-li-ji-shi-xian/">
        </link>
        <updated>2020-05-09T05:10:42.000Z</updated>
        <content type="html"><![CDATA[<p>问题：当前市场上手机屏幕宽度不尽相同，常见有320px（ipone5）、375px（ipone678）等等，而为了在不同宽度的手机屏幕上良好现显示网页，让页面能够在不同尺寸的屏幕上完美适配<br>
https://www.cnblogs.com/chenyoumei/p/10510321.html<br>
原理：实现屏幕宽度自适应主要有两种方案</p>
<ol>
<li>使用百分比长度单位：vh、vw、rem、em、%<br>
优点：一套css代码就可以适配所有屏幕</li>
<li>使用固定长度单位px，再用js根据当前设备屏幕宽度计算比例，对网页进行缩放；<br>
优点：网页宽度恒定，便于计算</li>
</ol>
<p>实现：</p>
<ol>
<li>rem布局：通过动态修改html font-size的大小来实现，1rem==页面根元素html的font-size大小。<br>
首先需要在meta标签中设置禁止缩放：<br>
<code>&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=0&quot;&gt;</code><br>
然后在页面加载是js动态获取当前视窗的宽度，计算得出相对于设计稿的比例，修改html的font-size大小</li>
</ol>
<pre><code class="language-js">function initFontSize(){
    var html = document.getElementsByTagName(&quot;html&quot;)[0];
    var width = window.innerWidth || document.documentElement.clientWidth || document.body.clientWidth;
    //假设视窗宽度为375px时，font-size为16px；
    html.style.fontSize = width/375 * 16 + 'px';
}
initFontSize();
//窗口大小变化时，重新计算font-size
window.onresize = ()=&gt;{ initFontSize() }
</code></pre>
<ol start="2">
<li>
<p>em：相对长度单位，相对于当前元素内字体的大小，如果当前元素没有设置字号，就找父元素的。</p>
</li>
<li>
<p>vw：相对于视窗的宽度，1vw为视窗宽度的1%。<br>
vw可以配合rem来实现屏幕自适应，移动端设计稿通常使用750px宽度，前端开发是通常使用375px的网页宽度，此时1vw=3.75px，4vh=15px；为了方便计算，可以设置html的字体大小为4vw；</p>
</li>
<li>
<p>%：单纯使用%无法确定元素高度，所以基本不用；</p>
</li>
<li>
<p>固定长度单位px，再使用js根据当前屏幕的宽度进行网页缩放</p>
</li>
</ol>
<ul>
<li>window.screen.width获取屏幕宽度</li>
<li>修改meta标签的initial-scale来改变页面初始缩放值</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[css position的几个属性值和性能问题]]></title>
        <id>https://liujia12138.github.io/post/css-position-de-ji-ge-shu-xing-zhi-he-xing-neng-wen-ti/</id>
        <link href="https://liujia12138.github.io/post/css-position-de-ji-ge-shu-xing-zhi-he-xing-neng-wen-ti/">
        </link>
        <updated>2020-05-09T03:52:24.000Z</updated>
        <content type="html"><![CDATA[<h4 id="position的属性值">position的属性值</h4>
<ol>
<li>
<p>relative 相对定位<br>
相对该元素的正常位置进行定位<br>
元素不会脱离标准文档流<br>
可通过z-index定义层叠关系</p>
</li>
<li>
<p>absolute 绝对定位<br>
相对于static定位以外的第一个定位的父元素进行绝对定位，如果没有就相对于浏览器窗口定位<br>
元素脱离标准文档流<br>
可通过z-index定义层叠关系</p>
</li>
<li>
<p>fixed 固定定位<br>
相对与浏览器窗口进行定位<br>
脱离标准文档流<br>
可通过z-index定义层叠关系</p>
</li>
<li>
<p>static 静态定位<br>
元素正常在文档流中出现，top、bottom、left、right都不起作用</p>
</li>
</ol>
<h4 id="副作用">副作用</h4>
<p>实现动画效果的时候，如果用position，我们会发现动画的运行不是很流畅，因为top和left的改变会触发浏览器的回流和重绘，没改变一次位置就回重新渲染一次元素，造成整个动画的过程都在不断触发浏览器的重新渲染，非常影响性能</p>
<p>如果把position用transform来实现的话，就不会这样，transform位置的改变不会引起浏览器的回流和重绘，因为transform动画是由cpu控制的，支持硬件加速</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[浏览器不同标签页之间传值]]></title>
        <id>https://liujia12138.github.io/post/liu-lan-qi-bu-tong-biao-qian-ye-zhi-jian-chuan-zhi/</id>
        <link href="https://liujia12138.github.io/post/liu-lan-qi-bu-tong-biao-qian-ye-zhi-jian-chuan-zhi/">
        </link>
        <updated>2020-05-09T01:52:11.000Z</updated>
        <content type="html"><![CDATA[<h3 id="1-使用localstorage">1. 使用localStorage</h3>
<p>在一个标签页里面使用 localStorage.setItem(key,value)添加（修改、删除）内容；<br>
在另一个标签页里面监听 storage 事件。<br>
即可得到 localstorge 存储的值，实现不同标签页之间的通信。</p>
<h3 id="2使用setintervalcookie">2.使用setInterval+cookie</h3>
<p>将要传递的信息存储在cookie中，每隔一定时间读取cookie信息，即可随时获取要传递的信息。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[js总结]]></title>
        <id>https://liujia12138.github.io/post/js-mian-shi-ti-zong-jie/</id>
        <link href="https://liujia12138.github.io/post/js-mian-shi-ti-zong-jie/">
        </link>
        <updated>2020-05-06T12:40:35.000Z</updated>
        <content type="html"><![CDATA[<p>1.事件冒泡和事件捕获<br>
事件捕获：事件从最不确定的元素向最准确的元素开始触发，即由外向内<br>
事件冒泡：事件从最准确的元素开始向最不准确的元素触发，即由内向外</p>
<p>addEventListener()有三个参数，第一个参数是绑定的事件类型；第二个是触发事件时执行的函数；第三个是 是否在捕获阶段触发事件，默认是false。</p>
<p>怎么阻止事件冒泡？event.stopPropagation()，vue项目中用stop修饰符</p>
<p>为什么要阻止事件冒泡？<br>
我们再多数情况下只使用冒泡监听。在一个列表页中，每一条信息中右下角会有一个删除按钮，同时点击这一条消息又会进入到详情页。当我们点击了删除按钮事件执行完毕之后，由于事件冒泡，会触发外层进入详情页的事件，这时就需要给删除按钮一个阻止事件传递的功能，点击删除按钮之后事件就会结束。</p>
<p>2.js获取url中的参数<br>
function getQueryString(name) {<br>
var reg = new RegExp(&quot;(^|&amp;)&quot; + name + &quot;=([^&amp;]*)(&amp;|$)&quot;, &quot;i&quot;);<br>
var r = window.location.search.substr(1).match(reg);<br>
if (r != null) return decodeURI(r[2]);<br>
return &quot;&quot;;<br>
}<br>
3.post请求能否跨域？<br>
post跨域问题本身是因为请求的域名和用于请求的机器域名不一致造成的，例如本地是127.0.0.1域名，请求的是192.168.50.11，在Network里面可以看到会接受到返回值，但是控制台会报请求头不一致的跨域问题，是因为浏览器对后台返给我结果进行了检测，发现两个环境域名不一致，所以解决的办法就是后台在接受到请求的时候，在返回头信息里面加入指定域名可访问或者所有域名都可以访问就可以，这样后台接收到请求之后的返回头里面就指定了对比的请求头，所以前端就能收到返回值了。</p>
<p>Access-Control-Allow-Headers: DNT,X-Mx-ReqToken,Keep-Alive,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type,Authorization,userid,sign<br>
Access-Control-Allow-Methods: GET, POST, OPTIONS<br>
Access-Control-Allow-Origin: *<br>
//加上过滤方法之后的返回头信息，*代表允许所有的域名访问<br>
4.页面性能优化<br>
减少http请求，减少http请求次数是缩短响应时间的关键，捆绑文件，将多个脚本文件捆绑成一个，以此来减少http请求次数<br>
使用css精灵图<br>
减少事件绑定，使用事件委托<br>
引用外部的css和js，而不是写在html文件内，有利于浏览器对文件进行缓存<br>
合理设置 HTTP缓存　　缓存的力量是强大的，恰当的缓存设置可以大大的减少 HTTP请求。以有啊首页为例，当浏览器没有缓存的时候访问一共会发出 78个请求，共 600多 K数据 (如图 1.1)，而当第二次访问即浏览器已缓存之后访问则仅有 10个请求，共 20多 K数据 (如图 1.2)。 (这里需要说明的是，如果直接 F5刷新页面的话效果是不一样的，这种情况下请求数还是一样，不过被缓存资源的请求服务器是 304响应，只有 Header没有Body ，可以节省带宽 )　　怎样才算合理设置 ?原则很简单，能缓存越多越好，能缓存越久越好。例如，很少变化的图片资源可以直接通过 HTTP Header中的Expires设置一个很长的过期头 ;变化不频繁而又可能会变的资源可以使用 Last-Modifed来做请求验证。尽可能的让资源能够在缓存中待得更久。<br>
减少dom操作<br>
5.原生ajax<br>
var xhr = new XMLHttpRequest();<br>
xhr.onreadystatechange= function(){<br>
if(xhr.readyState == 4 &amp;&amp; xhr.status == 200){<br>
console.log(xhr.responseText)<br>
}<br>
}<br>
//发送get请求时，参数直接拼接在url上<br>
xhr.open(&quot;get&quot;, &quot;url?param1=val1&amp;param2=val2&quot;);<br>
//发送post请求时，参数用send函数发送，并且需要设置请求头<br>
xhr.open(&quot;post&quot;, &quot;url&quot;);<br>
xhr.setRequestHeader('Content-Type', &quot;application/x-www-form-urlencoded&quot;)<br>
xhr.send(&quot;name=value&amp;age=12&quot;)<br>
6.js判断数据类型的方法<br>
typeof 只能对基本数据类型做出准确的判断，引用数据类型都会返回object，typeof的返回结果有：number、string、undefined、boolean、object、function六种，都是小写<br>
instanceof：判断对象和构造函数在原型链上是否有关联，有返回true，无返回false，基本数据类型无效<br>
constructor：查看对象对应的构造函数，当我们写一个构造函数的时候程序会自动添加；构造函数名.prototype.constructor=构造函数名；<br>
str.constructor == String;//true<br>
object.prototype.toString.call: 不管是什么类型都能检测出来<br>
7. call和apply,bind的区别？<br>
call、apply、bind的作用是改变函数运行时this的指向</p>
<p>2.js垃圾回收与内存泄漏？<br>
浏览器的JavaScript具有自动垃圾回收机制（GC），即执行环境会负责管理代码执行过程中的内存。原理是：垃圾收集器会定期找出那些不在继续使用的变量，然后将其内存进行释放。</p>
<p>垃圾回收机制标记无用变量的策略有两种：标记清除和引用计数。标记清除较为常用。</p>
<p>不在使用的变量就是生命周期结束的变量，只能是局部变量，因为全局变量的生命周期直到浏览器卸载页面是才会结束。局部变量只在函数的执行过程中存在，在这个过程中会在栈或者堆上为这个局部变量分配相应的空间用来存储他们的值，直到函数结束。但是闭包中由于你不函数的原因，外部函数不能算是结束。</p>
<p>function fn1(){<br>
var obj = {name: &quot;tom&quot;}<br>
}<br>
function fn2(){<br>
var obj = {name:&quot;tom&quot;};<br>
return obj;<br>
}<br>
var a = fn1();<br>
var b = fn2();<br>
上面的例子中，只有fn1中的obj会在调用结束后被垃圾回收机制回收，fn2中的obj不会，因为在fn2的调用过程中，返回的变量被变量b引用，所以不会改块内存不会被释放。</p>
<p>1.标记清除：当变量进入环境时，就将这个变量标记为“进入环境”，当变量离开环境时，将它标记为“离开环境”</p>
<p>function test(){<br>
var a = 10 ;       // 被标记 ，进入环境<br>
var b = 20 ;       // 被标记 ，进入环境<br>
}<br>
test();            // 执行完毕 之后 a、b又被标离开环境，被回收。<br>
2.引用计数：跟踪每个值被引用的次数，引用一次就将次数加1，如果包含这个值的变量又被赋了另外一个值，引用次数就减1，当引用次数为0时，垃圾回收机制就会释放该值所占用的内存。</p>
<p>function test() {<br>
var a = {};    // a指向对象的引用次数为1<br>
var b = a;     // a指向对象的引用次数加1，为2<br>
var c = a;     // a指向对象的引用次数再加1，为3<br>
var b = {};    // a指向对象的引用次数减1，为2<br>
}</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[css实现宽高比]]></title>
        <id>https://liujia12138.github.io/post/css-shi-xian-kuan-gao-bi/</id>
        <link href="https://liujia12138.github.io/post/css-shi-xian-kuan-gao-bi/">
        </link>
        <updated>2020-05-06T12:37:43.000Z</updated>
        <content type="html"><![CDATA[<p>垂直方向的padding+calc<br>
借助padding-top或者padding-bottom的百分比值来实现容器的宽高比，padding的百分比值是根据外层容器的宽度计算的，我们只需要设置好外层容器的宽度，并将容器的高度设置为0，容器所有子元素都设置绝对定位。</p>
<!-- html如下 -->
<div class='container'>
    <div class='aspectration' data-ratio='4:3'>
        <div class='content'></div>
    </div>
</div>
.container{
    width: 300px;
}
.aspectration{
    width: 100%;
    position: relative;
    height: 0;
}
.aspectration[data-ratio='4:3']{
    padding-top: calc(100% / 4 * 3);
}
.aspectration>*{
    position: absolute;
    width: 100%;
    height: 100%;
    left: 0;
    top: 0;
}]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[vue项目安装sass-loader]]></title>
        <id>https://liujia12138.github.io/post/vue-xiang-mu-an-zhuang-sass-loader/</id>
        <link href="https://liujia12138.github.io/post/vue-xiang-mu-an-zhuang-sass-loader/">
        </link>
        <updated>2020-05-06T12:36:12.000Z</updated>
        <content type="html"><![CDATA[<p>安装sass依赖包<br>
npm install sass-loader --save-dev<br>
安装node-sass，因为sass-loader依赖于node-sass<br>
npm install node-sass --save-dev<br>
在build文件夹下的webpack.base.conf.js的rules里面添加配置<br>
{<br>
test: &quot;sass&quot;,<br>
loader: ['style', 'css', 'sass']<br>
}</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[WebSocket]]></title>
        <id>https://liujia12138.github.io/post/websocket/</id>
        <link href="https://liujia12138.github.io/post/websocket/">
        </link>
        <updated>2020-01-08T12:37:41.000Z</updated>
        <content type="html"><![CDATA[<h4 id="websocket是什么">websocket是什么？</h4>
<p>是HTML5新增的属性，一种单个TCP连接上进行全双工通讯的网络通讯协议；</p>
<h4 id="websocket有什么用">websocket有什么用？</h4>
<p>为什么有了http协议，还需要websocket？因为http协议是单向通信协议，只能由客户端发起请求，无法做到服务端主动向客户端推送消息</p>
<p>当服务器有持续的变化时，客户端想要获取只能通过轮询的方法，每隔一段时间就发起一次请求，最典型的场景就是聊天发消息。</p>
<p>传统的http协议不能做到websocket实现的功能，因为http协议是一个请求-响应协议，只能由浏览器发起请求，服务器才能响应这个请求把数据发送给浏览器，服务器不能主动发起请求。</p>
<p>ajax轮询：每隔一段时间发起一个http请求，询问服务器有没有新消息，没有的话就一直发</p>
<p>长轮询：采用阻塞的方式，浏览器发起请求后，如果服务器没有新消息，就先拖一段时间一直不返回，直到有消息才返回，返回完之后，浏览器再次建立连接</p>
<p>ajax轮询和长轮询需要服务器有非常快的处理速度和很高的并发。</p>
<p>websocket最大的特点就是服务器可以主动向客户端发送消息。</p>
<p>其他特点：</p>
<ul>
<li>建立在tcp协议之上（tcp本身是双向通信，http协议对他做了限制，所以http协议只能是单向的）</li>
<li>与http协议有着良好的兼容性。默认端口也是80和443，而且握手阶段采用http协议</li>
<li>数据格式比较轻量，性能开销小</li>
<li>可以发送文本，也可以发送二进制文件</li>
<li>没有同源限制</li>
<li>协议标识符是ws（如果加密，就是wss）</li>
</ul>
<h4 id="使用websocket">使用websocket</h4>
<pre><code class="language-js">//在线运行https://jsbin.com/nobemozido/edit?js,console
if(!WebSocket){
    alert('您的浏览器不支持WebSocket')
}else{
    var ws = new WebSocket(&quot;url&quot;);
    ws.onopen = (evt) =&gt; {
        console.log(&quot;connection open...&quot;);
        ws.send(&quot;hello&quot;)
    }
    ws.onmessage = (evt) =&gt; {
        console.log(&quot;received message:&quot;+ evt.data);
        ws.close()
    }
    ws.onclose = (evt) =&gt;{
        console.log(&quot;connection closed&quot;);
    }
    ws.onerror = (evt) =&gt;{
        console.log(&quot;connection error&quot;);
    }
}
</code></pre>
<h4 id="api">API</h4>
<h5 id="1websocket构造函数">1.WebSocket构造函数</h5>
<h5 id="2websocketreadystate">2.WebSocket.readyState</h5>
<p>WebSocket实例对象的状态，一共有四种</p>
<ul>
<li>0：connecting，正在连接</li>
<li>1：open，连接成功，可以通信了</li>
<li>2：closeing，正在关闭</li>
<li>3：closed，已经关闭，或者打开失败</li>
</ul>
<h5 id="3websocketonopen">3.WebSocket.onopen</h5>
<p>用于指定连接成功之后的回调函数</p>
<p>如果想指定多个回调函数，可以使用addEventListener监听WebSocket实例</p>
<pre><code class="language-js">ws.addEventListener(&quot;open&quot;, (evt)=&gt;{
    ws.send(&quot;send message&quot;)
})
</code></pre>
<h5 id="4websocketonclose">4.WebSocket.onclose</h5>
<p>用于指定连接关闭后的回调函数</p>
<h5 id="5websocketonmessage">5.WebSocket.onmessage</h5>
<p>用于接收到服务器数据后的回调函数</p>
<h5 id="6websocketsend">6.WebSocket.send</h5>
<p>用于向服务器发送数据</p>
<pre><code class="language-js">ws.send(&quot;hello&quot;)
</code></pre>
<h5 id="7websocketclose">7.WebSocket.close</h5>
<p>用于关闭连接</p>
<pre><code class="language-js">ws.close()
</code></pre>
<h5 id="8websocketonerror">8.WebSocket.onerror</h5>
<p>用于指定连接错误时的回调函数</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[JS宏任务微任务和事件循环]]></title>
        <id>https://liujia12138.github.io/post/js-hong-ren-wu-wei-ren-wu-he-shi-jian-xun-huan/</id>
        <link href="https://liujia12138.github.io/post/js-hong-ren-wu-wei-ren-wu-he-shi-jian-xun-huan/">
        </link>
        <updated>2020-01-07T13:13:21.000Z</updated>
        <content type="html"><![CDATA[<p>js是一门单线程语言，所有任务都需要排队执行，如果上一个任务要消耗很长的时间，下一个任务都不得不等待很长时间，这时设计者就把任务分为了同步任务和异步任务。同步任务在主线程上一个个执行，异步任务则会加入到任务队列，只有所有同步任务执行完，才会执行异步任务。</p>
<p>异步任务有：setTimeout，setInterval，dom事件，promise， ajax</p>
<p>按照这样的话，上面例子的setTimeout和promise是异步任务，加入到任务队列然后依次执行，但并不是这样，任务又分为宏任务和微任务</p>
<p>宏任务和微任务：宏任务优先于微任务执行， 宏任务包括整体代码script，setTimeout，setInterval； 微任务包括promise，process.nextTick</p>
<p>所以上面的例子先打印start---然后遇到setTimeout，setTimeout属于异步任务也属于宏任务，放到task（宏任务队列）里面---然后是promise，也是异步任务，但是是微任务，所以放到microtask（微任务队列）里面---然后执行到最后打印end；此时主线程js stack被清空。</p>
<p>主线程执行完毕之后就会去清空微任务，所以接下来promise.then会被加入到主线程中去执行，执行完毕后，主线程又被清空了</p>
<p>此时微任务队列里还有刚刚产生的promise.then，又被加入到主线程，打印出promise2</p>
<p>此时微任务和主线程都被清空，接着从宏任务队列中取出一个宏任务加入到主线程中执行，打印出setTimeout</p>
<p>此时主线程，微任务队列，宏任务队列都被清空了。</p>
<p>如果宏任务队列和微任务队列还没清空，就会：主栈全部执行完毕后--&gt;清空微任务--&gt;会取出一个宏任务 --&gt; 执行完毕后--&gt;清空微任务 -&gt; 无线循环，这就是我们所说的事件环（Event Loop），也就是javascript的执行机制。</p>
<p>看下面的例子</p>
<pre><code>&lt;div class=&quot;outer&quot;&gt;
  &lt;div class=&quot;inner&quot;&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;script&gt;
// Let's get hold of those elements
var outer = document.querySelector('.outer');
var inner = document.querySelector('.inner');

// Let's listen for attribute changes on the
// outer element
//监听element属性变化
new MutationObserver(function() {
  console.log('mutate');
}).observe(outer, {
  attributes: true
});

// Here's a click listener…
function onClick() {
  console.log('click');

  setTimeout(function() {
    console.log('timeout');
  }, 0);

  Promise.resolve().then(function() {
    console.log('promise');
  });

  outer.setAttribute('data-random', Math.random());
}

// …which we'll attach to both elements
inner.addEventListener('click', onClick);
outer.addEventListener('click', onClick);
&lt;/script&gt;
</code></pre>
<p>点击inner会打印什么？</p>
<p>click事件是宏任务，加入到宏任务队列，setTimeout也是宏任务，promise和MutationObserver是微任务，加入到微任务队列 click promise mutate click promise mutate timeout timeout</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[http和https的区别？]]></title>
        <id>https://liujia12138.github.io/post/http-he-https-de-qu-bie/</id>
        <link href="https://liujia12138.github.io/post/http-he-https-de-qu-bie/">
        </link>
        <updated>2019-06-08T15:06:11.000Z</updated>
        <content type="html"><![CDATA[<p>http超文本传输协议，https是安全版的http</p>
<p>http和https的区别？</p>
<ol>
<li>http是超文本传输协议，信息是明文传输，https是具有安全性的ssl加密传输协议</li>
<li>连接方式不同，端口不同，http是80，https是443</li>
<li>https需要到CA申请证书</li>
<li>http连接很简单，是无状态的；https协议是由SSL/TLS+HTTP协议构建的</li>
</ol>
<p>http缺点：</p>
<p>通讯使用明文不加密，内容可能被窃听<br>
不验证通信方身份，可能遭到伪装<br>
无法验证报文完整性，可能被篡改<br>
https就是http加上<strong>加密处理+认证+完整性保护</strong></p>
<p>https的安全基础是<strong>SSL</strong>，SSL位于tcp/ip协议与各应用层协议之间，为数据通信提供安全支持。</p>
<p>SSL协议可以分为两层：SSL记录协议，建立在传输层协议（TCP）之上，为高层协议提供数据封装、压缩、加密等基本功能的支持；SSL握手协议，建立在SSL记录协议之上，用于实际的数据传输开始之前，通讯双方进行身份认证，协商加密算法，交换加密密钥等。</p>
<p>https设计目标：数据保密性、数据完整性、身份校验安全性</p>
<p>https://blog.csdn.net/qq_35642036/article/details/82788421</p>
<p>https原理：</p>
<ul>
<li>客户端将他支持的算法列表和一个用作产生密钥的随机数发送给服务器</li>
<li>服务端从算法列表中选择一种加密算法，将它和一份包含服务器公用秘钥的证书发送给客户端，该证书还包含用于认证目的的服务器标识，同时还提供了一个用作产生密钥的随机数</li>
<li>客户端对服务器证书进行验证，并抽取服务器的公用密钥，然后产生一个随机密码串，并且使用服务器的密钥对其加密，然后将加密后的信息发送给服务端</li>
<li>客户端与服务端根据随机密码串pre-master key以及客户端和服务端的随机数值独立计算出加密和MAC密钥，参考DH密钥交换算法</li>
<li>客户端将所有握手消息的MAC值发送给服务端</li>
<li>服务端将所有握手消息的MAC值发送给客户端</li>
</ul>
]]></content>
    </entry>
</feed>