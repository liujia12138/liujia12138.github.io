<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://liujia12138.github.io</id>
    <title>AzhA</title>
    <updated>2022-09-13T07:02:39.963Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://liujia12138.github.io"/>
    <link rel="self" href="https://liujia12138.github.io/atom.xml"/>
    <subtitle>温故而知新</subtitle>
    <logo>https://liujia12138.github.io/images/avatar.png</logo>
    <icon>https://liujia12138.github.io/favicon.ico</icon>
    <rights>All rights reserved 2022, AzhA</rights>
    <entry>
        <title type="html"><![CDATA[react 和 vue 中的 key 有什么作用？]]></title>
        <id>https://liujia12138.github.io/post/react-he-vue-zhong-de-key-you-shi-me-zuo-yong/</id>
        <link href="https://liujia12138.github.io/post/react-he-vue-zhong-de-key-you-shi-me-zuo-yong/">
        </link>
        <updated>2022-09-13T03:30:44.000Z</updated>
        <content type="html"><![CDATA[<h5 id="一-虚拟-dom-中-key-的作用">一. 虚拟 DOM 中 key 的作用：</h5>
<p>key 是虚拟 DOM 中对象的标识，当数据发生变化时，vue 会根据 新数据 生成 新的虚拟 DOM，随后 Vue 内部会进行 新虚拟 DOM 和 旧的虚拟 DOM 的差异对比（diff 算法）：</p>
<h6 id="对比规则">对比规则：</h6>
<ol>
<li>旧的虚拟 DOM 中找到与新的虚拟 DOM 中具有相同 key 值的 VNode</li>
</ol>
<ul>
<li>若虚拟 DOM 中内容没有发生变化，直接使用 之前的真实DOM，不会改变DOM</li>
<li>若虚拟 DOM 中内容发生了变化，则生成新的真实 DOM，随后替换掉页面中之前的真实 DOM</li>
</ul>
<ol start="2">
<li>旧的虚拟 DOM 中没有找到与新的虚拟 DOM 具有相同 key 值的 VNode<br>
创建新的真实 DOM，然后渲染到页面上</li>
</ol>
<h5 id="二-用-index-作为-key-值可能会引发的问题">二. 用 index 作为 key 值可能会引发的问题？</h5>
<ol>
<li>若对数据进行：逆序添加、逆序删除等破坏原有顺序的操作，会产生没有必要的真实 DOM 更新，页面效果没有问题，但是效率低（因为对数据的顺序进行了改变，导致没有发生变化的数据在渲染时也无法使用之前的真实DOM）</li>
<li>如果结构中还包含了输入类的 DOM，如 input，会产生错误的 DOM 更新，导致页面有问题，如：</li>
</ol>
<pre><code class="language-html">&lt;template&gt;
  &lt;div&gt;
    &lt;button @click=&quot;addPerson&quot;&gt;向列表前添加一个人&lt;/button&gt;
    &lt;ul&gt;
      &lt;li v-for=&quot;(item,index) in persons&quot; :key=&quot;index&quot;&gt;
        {{item.name}}---{{index}}
        &lt;!-- 每人一个输入框 --&gt;
        &lt;input type=&quot;text&quot; /&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
  export default{
    data(){
      return {
        person: [
          {
            name: '张三',
            id: '001'
          },{
            name: '李四',
            id: '002'
          },{
            name: '王五',
            id: '003'
          }
        ]
      }
    },
    methods:{
      addPerson(){
        let p = {
          name: '老刘',
          id: '004
        }
        this.person.upshift(p)
      }
    }
  }
&lt;/script&gt;
</code></pre>
<p>页面渲染出persons列表后在每行的input中输入姓名<br>
效果图:<br>
<img src="https://liujia12138.github.io/post-images/1663040035727.jpg" alt="" loading="lazy"></p>
<p>点击按钮，添加老刘后<br>
<img src="https://liujia12138.github.io/post-images/1663040050410.jpg" alt="" loading="lazy"></p>
<p>此时页面上老刘数据添加到persons的第一位，姓名和index都正常渲染，但是input出现了错位的情况。<br>
这是因为旧的虚拟DOM中张三和新的虚拟DOM中老刘具有相同的key：0，diff算法在进行差异对比时，发现name不同，然后页面渲染时就会渲染上新的name，但是对于input，由于上一步在input中输入姓名的操作是发生在真实DOM中的，没有影响到虚拟DOM，所以，在进行对比时会认为这一部分没有发生变化，这时页面就会继续使用上一次渲染的input，这也就导致了‘老刘’这条数据在页面上的input是张三的。</p>
<p>对比过程图<br>
<img src="https://liujia12138.github.io/post-images/1663040060872.jpg" alt="" loading="lazy"></p>
<h5 id="三开发中如何选择key">三.开发中如何选择key？</h5>
<ol>
<li>最好使用每条数据的唯一标识作为key，比如id，手机号，身份证号等唯一值</li>
<li>如果不存在对数据逆序添加、逆序删除等破坏顺序的操作，仅用于渲染列表展示，使用index作为key是不会有问题的</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[el-table自定义表头内数据不更新的问题]]></title>
        <id>https://liujia12138.github.io/post/el-table-zi-ding-yi-biao-tou-nei-shu-ju-bu-geng-xin-de-wen-ti/</id>
        <link href="https://liujia12138.github.io/post/el-table-zi-ding-yi-biao-tou-nei-shu-ju-bu-geng-xin-de-wen-ti/">
        </link>
        <updated>2021-09-29T06:56:13.000Z</updated>
        <content type="html"><![CDATA[<h3 id="el-table自定义表头使用slotheader数据无法更新">el-table自定义表头，使用slot=&quot;header&quot;数据无法更新</h3>
<p>解决方法：将slot=“header” 改成#header</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[ECharts引入外部字体]]></title>
        <id>https://liujia12138.github.io/post/echarts-yin-ru-wai-bu-zi-ti/</id>
        <link href="https://liujia12138.github.io/post/echarts-yin-ru-wai-bu-zi-ti/">
        </link>
        <updated>2021-09-15T06:50:51.000Z</updated>
        <content type="html"><![CDATA[<h3 id="问题描述echarts引入外部字体文件时页面渲染异常出现部分文字没有渲染成指定字体的情况"><strong>问题描述</strong>：echarts引入外部字体文件时，页面渲染异常，出现部分文字没有渲染成指定字体的情况</h3>
<p>如图:<br>
<img src="https://liujia12138.github.io/post-images/1663052022764.png" alt="" loading="lazy"></p>
<h3 id="原因字体文件未加载完成就完成了echarts图表部分的代码">原因：字体文件未加载完成就完成了echarts图表部分的代码</h3>
<h3 id="解决办法等字体下载完再画图或者压缩字体文件">解决办法：等字体下载完再画图或者压缩字体文件</h3>
<pre><code class="language-js">document.fonts.ready.then(()=&gt;{
  //执行echarts图
})
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[uniapp如何在小程序端模拟数据]]></title>
        <id>https://liujia12138.github.io/post/uniapp-ru-he-zai-xiao-cheng-xu-duan-mo-ni-shu-ju/</id>
        <link href="https://liujia12138.github.io/post/uniapp-ru-he-zai-xiao-cheng-xu-duan-mo-ni-shu-ju/">
        </link>
        <updated>2021-03-09T06:58:01.000Z</updated>
        <content type="html"><![CDATA[<h3 id="问题描述使用uniapp开发小程序发现运行到微信开发者工具时用mockjs模拟数据接口无法使用">问题描述：使用uniapp开发小程序，发现运行到微信开发者工具时用mockjs模拟数据接口无法使用</h3>
<h3 id="解决办法">解决办法</h3>
<p>使用better-mock</p>
<h4 id="安装better-mock">安装better-mock</h4>
<p>[官方文档]&lt;!https://lavyun.github.io/better-mock/document/&gt;</p>
<pre><code>cnpm install better-mock --save-D
</code></pre>
<h4 id="引入better-mock">引入better-mock</h4>
<p>因为better-mock完全兼容mockjs，只需要将mock目录下index.js中</p>
<pre><code>const Mock = require('mockjs')
</code></pre>
<p>改为</p>
<pre><code>const Mock = require('better-mock/dist/mock.mp.js')
</code></pre>
<p>再次运行就可以在微信开发者工具看到模拟的数据啦</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[vue报错You are using the runtime-only build of Vue where the template compiler is not available]]></title>
        <id>https://liujia12138.github.io/post/vue-bao-cuo-you-are-using-the-runtime-only-build-of-vue-where-the-template-compiler-is-not-available/</id>
        <link href="https://liujia12138.github.io/post/vue-bao-cuo-you-are-using-the-runtime-only-build-of-vue-where-the-template-compiler-is-not-available/">
        </link>
        <updated>2021-03-02T06:59:17.000Z</updated>
        <content type="html"><![CDATA[<h3 id="问题描述使用vueant-design-vue时因为menu组件在v20之前不支持单文件递归所以使用了函数式组件但是编译时出现了下面的报错">问题描述：使用vue+ant-design-vue时，因为Menu组件在V2.0之前不支持单文件递归，所以使用了函数式组件，但是编译时出现了下面的报错</h3>
<pre><code>[Vue warn]: You are using the runtime-only build of Vue where the template compiler is not available. Either pre-compile the templates into render functions, or use the compiler-included build.
</code></pre>
<p>翻译：您正在使用仅在运行时构建的Vue，其中模板编译器不可用。要么将模板预编译为呈现函数，要么使用包含编译器的构建。</p>
<h4 id="原因">原因：</h4>
<p>vue的构建版本分为：UMD， CommonJS，ES Module<br>
<a href="https://cn.vuejs.org/v2/guide/installation.html">https://cn.vuejs.org/v2/guide/installation.html</a></p>
<p><img src="https://liujia12138.github.io/post-images/1663052383565.png" alt="构建版本" loading="lazy"><br>
<img src="https://liujia12138.github.io/post-images/1663052405859.png" alt="术语" loading="lazy"></p>
<p>vue默认的是运行时的版本，无法处理模板字符串的编译工作，需要使用包含编译器的构建</p>
<p>当需要客户端编译模板，如向template中传入一个字符串，或者需要将模板中的非DOM挂载到一个元素上时，就需要带有编译器（compiler）的构建版本。</p>
<p>而.vue文件中的模板会在构建时预编译（pre-compile）为JavaScript，最终生成的bundle中不再需要编译器，因此通常情况下只需要包含运行时（runtime-only）的构建版本</p>
<h4 id="解决方法">解决方法</h4>
<p>在项目目录下新建vue.config.js，添加配置，使用包含运行时编译器的构建版本</p>
<pre><code class="language-js">module.exports = {
  //Solution For Issue:You are using the runtime-only build of Vue where the template compiler is not available. Either pre-compile the templates into render functions, or use the compiler-included build.
  runtimeCompiler: true
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[css实现文字渐变色]]></title>
        <id>https://liujia12138.github.io/post/css-shi-xian-wen-zi-jian-bian-se/</id>
        <link href="https://liujia12138.github.io/post/css-shi-xian-wen-zi-jian-bian-se/">
        </link>
        <updated>2021-02-25T06:47:57.000Z</updated>
        <content type="html"><![CDATA[<h4 id="实现文字颜色渐变有两种方法">实现文字颜色渐变有两种方法</h4>
<ol>
<li>使用 background-clip 属性</li>
</ol>
<pre><code class="language-css">.text {
  background: linear-gradient(90deg, #326be6 0%, #0fcae2 100%);
  -webkit-background-clip: text;
  color: transparent;
}
</code></pre>
<h5 id="扩展">扩展</h5>
<ul>
<li>background-clip,背景裁剪,作用就是设置背景的填充规则<br>
和 box-sizing 的取值非常类似，有三个值</li>
</ul>
<pre><code class="language-css"> {
  background-clip: border-box; /*背景延伸到边框外延，但是再边框之下*/
  background-clip: content-box; /*背景剪裁到内容区外沿*/
  background-clip: padding-box; /*背景延伸到内边距外沿*/
}
</code></pre>
<ul>
<li>background-clip: text; 只有 chrome 支持，需要写成 -webkit-background-clip:text<br>
以区块内的文字作为裁剪区域向外剪裁。文字的背景即为区块的背景，通常需要配合文字颜色设置为 transparent</li>
</ul>
<p>示例：</p>
<pre><code class="language-css">.text {
  color: transparent;
  border: 5px solid transparent;
  background: linear-gradient(120deg, #333 0%, #265fae 30%, red 60%, pink 100%);
  background-clip: content-box;
  -webkit-background-clip: text;
  font-size: 60px;
}
</code></pre>
<p>效果图:<br>
<img src="https://liujia12138.github.io/post-images/1663051783274.png" alt="" loading="lazy"></p>
<ol>
<li>使用 mask-image 属性</li>
</ol>
<p>示例</p>
<pre><code class="language-css">.text {
  color: red;
  font-size: 60px;
  position: relative;
}
.text[data-content]::after {
  content: attr(data-content);
  display: block;
  color: yellow;
  z-index: 2;
  position: absolute;
  top: 0;
  left: 0;
  -webkit-mask-image: linear-gradient(180deg, yellow 0%, transparent 100%);
  mask-image: linear-gradient(180deg, yellow 0%, transparent 100%);
}
</code></pre>
<pre><code class="language-html">&lt;div class=&quot;text&quot; data-content=&quot;content&quot;&gt;content&lt;/div&gt;
</code></pre>
<figure data-type="image" tabindex="1"><img src="https://liujia12138.github.io/post-images/1663051769813.png" alt="" loading="lazy"></figure>
<p>其实就是将一个黄色到透明渐变的文字覆盖到本身红色的字上面，mask-image兼容性要高于第一种方法</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[vue项目如何实现版本控制，用以保证用户的浏览器资源为最新]]></title>
        <id>https://liujia12138.github.io/post/vue-xiang-mu-ru-he-shi-xian-ban-ben-kong-zhi-yong-yi-bao-zheng-yong-hu-de-liu-lan-qi-zi-yuan-wei-zui-xin/</id>
        <link href="https://liujia12138.github.io/post/vue-xiang-mu-ru-he-shi-xian-ban-ben-kong-zhi-yong-yi-bao-zheng-yong-hu-de-liu-lan-qi-zi-yuan-wei-zui-xin/">
        </link>
        <updated>2021-01-29T07:01:03.000Z</updated>
        <content type="html"><![CDATA[<h3 id="问题描述项目实际使用过程中由于浏览器缓存问题可能会导致使用的版本不是服务器上部署的最新版本需要在项目中写入版本号">问题描述：项目实际使用过程中，由于浏览器缓存问题，可能会导致使用的版本不是服务器上部署的最新版本，需要在项目中写入版本号</h3>
<h3 id="如何解决问题">如何解决问题？</h3>
<h4 id="1-在vueconfigjs中加上写入版本号逻辑">1. 在vue.config.js中，加上写入版本号逻辑</h4>
<pre><code class="language-js">const fs = require('fs')
const path = require('path')

const resolve = dir =&gt; {
  return path.join(__dirname, dir)
}

const TimeStamp = new Date().getTime()

// 写入版本号
if(process.env.NODE_ENV === 'production'){
  process.env.VUE_APP_VERSION = TimeStamp;

  // 写入到.env文件中
  fs.writeFile(resolve('.env'), `VUE_APP_VERSION=${TimeStamp}`, err=&gt;{
    if(err){
      return console.log(err)
    }
    console.log(`版本号变量写入成功：${TimeStamp}`)
  })

  // 写入到public的文件
  fs.writeFile(resolve('public/v.json'), JSON.stringify({version: TimeStamp}), err =&gt; {
    if(err){
      return console.log(err)
    }
    console.log(`版本号写入成功：${TimeStamp}`)
  })
}
</code></pre>
<h4 id="2-在routerindexjs中加入判断版本号逻辑">2. 在router/index.js中加入判断版本号逻辑</h4>
<pre><code class="language-js">router.beforeEach(async(to, from, next)=&gt;{
  // 获取版本号
  let version = await http.get(`${location.origin}/v.json`).then(res =&gt; {
    return res.data.version
  })

  if(process.env.NODE_ENV === 'production' &amp;&amp; process.env.VUE_APP_VERSION !== version){
    // 提示存在新版本
    MessageBox('系统版本有更新，可按【CTRL + F5】或【清除浏览器缓存】获取最新资源', '提示').then(_ =&gt; {
      window.location.reload()
    }).catch(_ =&gt; {})
    return;
  }
  // ......
})
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[canvas和svg]]></title>
        <id>https://liujia12138.github.io/post/canvas-he-svg/</id>
        <link href="https://liujia12138.github.io/post/canvas-he-svg/">
        </link>
        <updated>2020-10-22T09:43:24.000Z</updated>
        <content type="html"><![CDATA[<p>canvas和svg都是html5中新增的属性，都允许在浏览器中创建图形，但他们的实现原理是不同的；</p>
<h4 id="svg使用xml来描述2d图形">svg使用XML来描述2D图形</h4>
<p>svg基于XML，这意味着svg中的每个元素都是可用的，可以为某个元素添加JavaScript事件处理器<br>
在svg中，每个被绘制的图形都被视为一个对象，如果svg对象的属性发生变化，浏览器会自动重现图形</p>
<h4 id="canvas使用javascript来绘制2d图形">canvas使用JavaScript来绘制2D图形</h4>
<p>canvas是逐像素进行渲染的，在canvas中，一旦图形被绘制出来，它就不会再继续得到浏览器的关注。</p>
<figure data-type="image" tabindex="1"><img src="https://liujia12138.github.io/post-images/1603360168164.png" alt="" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[HTTP报文的结构]]></title>
        <id>https://liujia12138.github.io/post/http-bao-wen-de-jie-gou/</id>
        <link href="https://liujia12138.github.io/post/http-bao-wen-de-jie-gou/">
        </link>
        <updated>2020-10-22T08:12:39.000Z</updated>
        <content type="html"><![CDATA[<p>http通信过程包括客户端王服务端发送请求以及服务端给客户端返回响应两个过程，在这两个过程中会产生请求报文和响应报文。</p>
<p>http报文由报文首部和报文主体组成，中间由一个空行分隔。报文首部是客户端或服务端需要处理的请求或响应的内容及属性，可以传递额外的重要信息。报文首部包括请求行和请求头部，报文主体主要包含应被发送的数据。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[prerender-spa-plugin 实现vue预渲染]]></title>
        <id>https://liujia12138.github.io/post/prerender-spa-plugin-shi-xian-vue-yu-xuan-ran/</id>
        <link href="https://liujia12138.github.io/post/prerender-spa-plugin-shi-xian-vue-yu-xuan-ran/">
        </link>
        <updated>2020-10-22T02:59:31.000Z</updated>
        <content type="html"><![CDATA[<p>为什么要做预渲染？<br>
预渲染配置生成多页面，解决首屏白屏问题，提升用户体验。同时配合vue-meta-info可以生成title和meta标签，解决单页面应用seo问题。</p>
<p>如何使用prerender-spa-plugin？</p>
<ol>
<li>
<p>安装prerender-spa-plugin和vue-meta-info<br>
<code>cnpm install prerender-spa-plugin vue-meta-info --save</code></p>
</li>
<li>
<p>router.js中，将路由模式改为history</p>
</li>
<li>
<p>vue2.0项目在webpack.prod.conf.js中配置prerender-spa-plugin</p>
</li>
</ol>
<pre><code class="language-js">const PrerenderSpaPlugin = require('prerender-spa-plugin')
const renderer = PrerenderSpaPlugin.PuppeteerRenderer

//plugins中加入
new PrerenderSpaPlugin({
    // 编译后html存放的路径
    staticDir: path.join(__dirname, '../dist'),
    // 需要做预渲染的路由
    routes: ['/about'],
    // 配置renderer，选择预渲染使用的引擎，否则不会进行预编译
    renderer: new renderer({
        // 监听document.dispatchEvent事件，决定什么时候开始渲染，需要在main.js中加入如下配置
        renderAfterDocumentEvent: 'render-event'
    })
})
</code></pre>
<pre><code class="language-js">new Vue({
    ...,
    mounted(){
        document.dispatchEvent(new Event('render-event'))
    }
})
</code></pre>
<ol start="4">
<li>使用vue-meta-info</li>
</ol>
<ul>
<li>在main.js中引入vue-meta-info并安装</li>
</ul>
<pre><code class="language-js">import MetaInfo from 'vue-meta-info'
Vue.use(MetaInfo)
</code></pre>
<ul>
<li>组件内配置MetaInfo</li>
</ul>
<pre><code class="language-html">&lt;template&gt;
    &lt;div&gt;about page.....&lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
    export default{
        metaInfo:{
            title: '关于我们',
            meta: [
                {
                    name: 'keywords',
                    content: '这个页面是about'
                }
            ]
        }
    }
&lt;/script&gt;
</code></pre>
<ol start="5">
<li>配置完成后运行npm run build就可以在dist目录内看到预渲染后的html文件了</li>
</ol>
]]></content>
    </entry>
</feed>